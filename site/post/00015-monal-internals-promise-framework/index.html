<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Monal Internals - Serializable Promise framework | Monal</title><meta name=keywords content><meta name=description content="In this new series, I want to shine some light onto specific parts of Monal&rsquo;s internals. It&rsquo;s dedicated to programmers or people curious about how Monal works internally.
If you want to give some feedback, feel free to send an email to thilo@monal-im.org
Other articles in this series:

Monal Internals - Handlers framework
Monal Internals - XML Query Language

Serializable Promise Framework
XMPP as a protocol is, as most protocols are, inherently asynchronous.
In Monal we therefore use the popular PromiseKit library
to let the UI know when a XMPP action finished or failed."><meta name=author content="Matthew Fennell"><link crossorigin=anonymous href=/monal-im.org/site/assets/css/stylesheet.7a0e5ac2a2e5cdd92faa4135726b158cb7b667d84e36e242d67c14818720c427.css integrity="sha256-eg5awqLlzdkvqkE1cmsVjLe2Z9hONuJC1nwUgYcgxCc=" rel="preload stylesheet" as=style fetchpriority=high><link rel=apple-touch-icon sizes=57x57 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_aed0bf773d0fe8e6.png fetchpriority=medium><link rel=apple-touch-icon sizes=60x60 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_40f307db0c000ac3.png fetchpriority=medium><link rel=apple-touch-icon sizes=72x72 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_e8ffb71aeedfe957.png fetchpriority=medium><link rel=apple-touch-icon sizes=76x76 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_cb51b2ba7c7e14f9.png fetchpriority=medium><link rel=apple-touch-icon sizes=114x114 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_deb92bce47608e57.png fetchpriority=low><link rel=apple-touch-icon sizes=120x120 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_1f0a9fc237907f90.png fetchpriority=low><link rel=apple-touch-icon sizes=144x144 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_f786603bba03566e.png fetchpriority=low><link rel=apple-touch-icon sizes=152x152 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_fb920aa7392d52dd.png fetchpriority=low><link rel=apple-touch-icon sizes=180x180 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_240909a03da8f61b.png fetchpriority=low><link rel=icon type=image/x-icon href=https://monal-im.github.io/monal-im.org/site/favicons/favicon.ico fetchpriority=medium><link rel=icon type=image/png sizes=16x16 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_d70bc8f41e729efc.png fetchpriority=medium><link rel=icon type=image/png sizes=32x32 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_16139a6914f19029.png fetchpriority=medium><link rel=icon type=image/png sizes=96x96 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_427cae698d5cbff6.png fetchpriority=low><link rel=icon type=image/png sizes=128x128 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_b1d627f0ca014313.png fetchpriority=low><link rel=icon type=image/png sizes=196x196 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_2bc41f2942134f62.png fetchpriority=low><link rel=mask-icon color=red href=favicons/safari-pinned-tab.svg fetchpriority=low><meta name=application-name content="Monal-IM"><meta name=msapplication-TileColor content="#FFFFFF"><meta name=msapplication-square70x70logo content="https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_bc237ba0813e0c71.png" fetchpriority=medium><meta name=msapplication-TileImage content="https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_f786603bba03566e.png" fetchpriority=low><meta name=msapplication-square150x150logo content="https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_4e7d56e0daf0bb8e.png" fetchpriority=low><meta name=msapplication-square310x310logo content="https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_38f348dfd83673b6.png" fetchpriority=low><meta property="og:url" content="https://monal-im.github.io/monal-im.org/site/post/00015-monal-internals-promise-framework/"><meta property="og:site_name" content="Monal"><meta property="og:title" content="Monal Internals - Serializable Promise framework"><meta property="og:description" content="In this new series, I want to shine some light onto specific parts of Monal‚Äôs internals. It‚Äôs dedicated to programmers or people curious about how Monal works internally. If you want to give some feedback, feel free to send an email to thilo@monal-im.org
Other articles in this series:
Monal Internals - Handlers framework Monal Internals - XML Query Language Serializable Promise Framework XMPP as a protocol is, as most protocols are, inherently asynchronous. In Monal we therefore use the popular PromiseKit library to let the UI know when a XMPP action finished or failed."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-12-14T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-16T11:35:18+01:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://monal-im.github.io/monal-im.org/site/post/"},{"@type":"ListItem","position":2,"name":"Monal Internals - Serializable Promise framework","item":"https://monal-im.github.io/monal-im.org/site/post/00015-monal-internals-promise-framework/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Monal Internals - Serializable Promise framework","name":"Monal Internals - Serializable Promise framework","description":"In this new series, I want to shine some light onto specific parts of Monal\u0026rsquo;s internals. It\u0026rsquo;s dedicated to programmers or people curious about how Monal works internally. If you want to give some feedback, feel free to send an email to thilo@monal-im.org\nOther articles in this series:\nMonal Internals - Handlers framework Monal Internals - XML Query Language Serializable Promise Framework XMPP as a protocol is, as most protocols are, inherently asynchronous. In Monal we therefore use the popular PromiseKit library to let the UI know when a XMPP action finished or failed.\n","keywords":[],"articleBody":"In this new series, I want to shine some light onto specific parts of Monal‚Äôs internals. It‚Äôs dedicated to programmers or people curious about how Monal works internally. If you want to give some feedback, feel free to send an email to thilo@monal-im.org\nOther articles in this series:\nMonal Internals - Handlers framework Monal Internals - XML Query Language Serializable Promise Framework XMPP as a protocol is, as most protocols are, inherently asynchronous. In Monal we therefore use the popular PromiseKit library to let the UI know when a XMPP action finished or failed.\nBut this has a huge drawback: PromiseKit-based promises aren‚Äôt serializable, so we can‚Äôt respond to events that got handled by the Notification Service App Extension while the app was suspended. The serializable promise framework is a new framework in Monal, which exactly fills that gap.\nOverall Process For instance, imagine you want to remove the avatar of a group chat in Monal, while on a slow, unreliable network.\nYou submit the request, and the loading screen appears over the view (0:03) Because the network is slow, the loading screen persists for a long time You get frustrated and switch apps, sending Monal to the background (0:06) After 30s in the background, Monal gets suspended (0:36) The server fails to remove the avatar and sends an error to Monal The response is handled by Monal‚Äôs app extension in the background (0:51) You switch apps back to Monal (0:57) Without the promise framework, the app would have continued to show the loading screen indefinitely, requiring you to fully close and open the app.\nHowever, with the promise framework, when you switch back to the app, the loading screen disappears and correctly shows the error returned by the server:\nYour browser does not support the video element. The promise framework allows any such interaction, where the UI has to update in response from the server, to be handled in a general way.\nBackground We will briefly describe the important parts below. But these links provide more detailed context and are recommended reading:\nThe app decomposition slides explain the split between the main app and app extension. The handler framework blog post explores some of the consequences of this split. Main app and app extension In Monal there are two separate processes: the ‚Äúmain app‚Äù (MonalAppDelegate) and ‚Äúapp extension‚Äù (NotificationService), which is sometimes abbreviated to ‚Äúappex‚Äù.\nSince they do not share memory, they hand over to each other via the handler framework.\nAn xmpp stanza can be processed by either, depending on whether the app is running or not:\nApp states Below is a slightly simplified diagram of the app‚Äôs lifecycle. A more detailed lifecycle from Apple‚Äôs perspective is available here.\nState Description App not running App is not running, and when it is opened, it will start afresh App active App is open and in the foreground App in background App is running, but in the background App suspended App is not running, but its state is saved for when the app is reopened The app moves from ‚Äúactive‚Äù to ‚Äúin background‚Äù when it is swiped away without being closed It continues to run and process stanzas for ~30s in the background Once the 30s are complete, it moves to ‚Äúsuspended‚Äù Apple saves the UI‚Äôs state When the app is reopened, it returns to the same screen as before Any stanzas that were processed in the meantime were processed by the appex Appex states Meanwhile, the appex has a more simple lifecycle - it is either running, or not running:\nOnce the appex starts, it will connect to the server and run for 30s If the app is opened while the appex is running, the appex will return to ‚Äúnot running‚Äù state in deference to the app. Serializable promise framework Ok, now the background is out of the way, time to explain the promise framework!\nWhile promises are very useful in SwiftUI, there is one problem: they only exist in that particular process, and cannot easily be passed between the app and appex.\nThis means that, if the promise was resolved in the appex, once the app is reopened (moves from suspended to active), it will not be consumed. This is because the appex has no way of tying the result back to the promise that updates the UI.\nSince the handler framework is what allows the seamless handoff between the app and appex, we need a way to trigger consumption of a promise as a result of processing in the handler. This is precisely what the promise framework does!\nHigh-level overview We create a ‚Äúserializable promise‚Äù class called MLPromise. This class stores a ‚ÄúUI promise‚Äù which is an AnyPromise from PromiseKit. Consumption of this AnyPromise is what ultimately causes the UI to update.\nWhenever we want to bind a UI action to the result of a handler, we create an MLPromise and pass it as an argument to the handler. We then return the MLPromise‚Äôs AnyPromise to the UI.\nUnlike the AnyPromise it contains, the MLPromise is (mostly) serializable. When the MLPromise is created, and whenever it is resolved, it persists itself to a new promises table in the database.\nMeanwhile, whenever the app or appex is unfrozen, and the promise table is read into memory, the resolved arguments of any already existing promises are overwritten.\nNote that this persisted version of the MLPromise is not complete - while the resolved argument can be persisted, the UI promise is not persisted at any stage.\nThis means that, while the resolved argument can be passed betwen the app and appex, the UI promise itself cannot. The consequence of this is that a promise cannot be consumed in the appex - it can only be resolved there, leaving consumption for when the app becomes active again:\nProcess Can resolve? Can consume? App Yes Yes Appex Yes No This makes some sense, as the whole purpose of the AnyPromise is to update the UI as a result of some backend action. It only makes sense to update the UI from the process which manages the UI - the app itself.\nAs a result, whenever the app becomes active again, all outstanding MLPromises check the version retrieved from the DB if they have been resolved in the meantime, and if so, consume themselves. This is how the loading overlay gets removed in the above example.\nStep-by-step overview Let‚Äôs return to the initial scenario of removing the avatar of a group chat. The user chooses the new avatar and presses submit. Then, the following happens:\n(1) UI code calls backend The UI code responding to requests to remove the avatar calls the backend method to do this.\nOnce the backend function completes, it will return an AnyPromise, allowing the UI code to continue immediately:\nshowPromisingLoadingOverlay(overlay, headlineView:Text(\"Removing avatar...\"), descriptionView:Text(\"\")) { // this returns an AnyPromise used by the loading overly to hide itself once it gets resolved self.account.mucProcessor.publishAvatar(nil, forMuc: contact.contactJid) } (2) Core code creates promise The core code creates an MLPromise:\n-(AnyPromise*) publishAvatar:(UIImage* _Nullable) image forMuc:(NSString*) room { MLPromise* promise = [MLPromise new]; // ... (3) Core code creates handler and (4) sends IQ The core code creates a new handler, and passes the MLPromise to it as an argument. Recall that handlers serialize their arguments - this means that, even if the app is suspended and the handler is called in the appex, the MLPromise will be available.\n[_account sendIq:vcard withHandler:$newHandlerWithInvalidation(self, handleAvatarPublishResult, handleAvatarPublishResultInvalidation, $ID(room), $ID(promise))]; (5) Promise returned to UI Internally, the MLPromise has created an AnyPromise. This is a type provided by PromiseKit that can be returned directly to the UI, and that the SwiftUI code understands. It gets returned to the UI code.\nreturn [promise toAnyPromise]; (6) XMPP server provides response This happens on the server side and is not relevant to Monal.\nHowever, while waiting for the response, the user puts the app into the background, and the app gets suspended.\n(7) Handler resolves promise Now, the response from the server activates the appex, since the app was suspended.\nThe handler is called with the response from the server. It resolves the promise (via either reject or fulfill) - passing that response to the promise.\n$$instance_handler(handleAvatarPublishResult, account.mucProcessor, $$ID(xmpp*, account), $$ID(XMPPIQ*, iqNode), $$ID(MLPromise*, promise)) if([iqNode check:@\"/","wordCount":"1649","inLanguage":"en","datePublished":"2025-12-14T00:00:00Z","dateModified":"2025-12-16T11:35:18+01:00","author":{"@type":"Person","name":"Matthew Fennell"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://monal-im.github.io/monal-im.org/site/post/00015-monal-internals-promise-framework/"},"publisher":{"@type":"Organization","name":"Monal","logo":{"@type":"ImageObject","url":"https://monal-im.github.io/monal-im.org/site/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://monal-im.github.io/monal-im.org/site/ accesskey=h title="Monal (Alt + H)">Monal</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li class=menu-item><a href=/monal-im.org/site/install/ title=Install><span>Install</span></a></li><li class=menu-item><a href=/monal-im.org/site/support/ title=Support><span>Support</span></a></li><li class=menu-item><a href=/monal-im.org/site/post/ title=Blog><span>Blog</span></a></li><li class=menu-item><a href=/monal-im.org/site/publications/ title=Publications><span>Publications</span></a></li><li class=menu-item><a href=/monal-im.org/site/privacy/ title=Privacy><span>Privacy</span></a></li><li class=menu-item><a href=/monal-im.org/site/about/ title=About><span>About</span></a></li><li class=menu-item><a href=https://github.com/monal-im/Monal/wiki title=Wiki><span>Wiki</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li class=menu-item><a href=/monal-im.org/site/search/ title="Search üîç (Alt + /)" accesskey=/><span>Search üîç</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Monal Internals - Serializable Promise framework</h1><div class=post-meta><span title='2025-12-14 00:00:00 +0000 UTC'>14.12.2025</span>&nbsp;¬∑&nbsp;8 min&nbsp;¬∑&nbsp;Matthew Fennell<a href=/index.xml rel="noopener noreferrer" target=_blank>&nbsp;RSS</a>&nbsp;|&nbsp;<a href=https://github.com/monal-im/monal-im.org/tree/staging/content/post/00015-monal-internals-promise-framework/index.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>In this new series, I want to shine some light onto specific parts of Monal&rsquo;s internals. It&rsquo;s dedicated to programmers or people curious about how Monal works internally.
If you want to give some feedback, feel free to send an email to <a href=mailto:thilo@monal-im.org>thilo@monal-im.org</a></p><p><strong>Other articles in this series:</strong></p><ul><li><a href=/monal-im.org/site/post/00007-monal-internals-handlers/>Monal Internals - Handlers framework</a></li><li><a href=/monal-im.org/site/post/00014-monal-internals-xml-query-language/>Monal Internals - XML Query Language</a></li></ul><h1 id=serializable-promise-framework>Serializable Promise Framework<a hidden class=anchor aria-hidden=true href=#serializable-promise-framework>#</a></h1><p>XMPP as a protocol is, as most protocols are, inherently asynchronous.
In Monal we therefore use the popular <a href=https://github.com/mxcl/PromiseKit>PromiseKit</a> library
to let the UI know when a XMPP action finished or failed.</p><p>But this has a huge drawback: PromiseKit-based promises aren&rsquo;t serializable, so we can&rsquo;t respond to events
that got handled by the Notification Service App Extension while the app was suspended.
The serializable promise framework is a new framework in Monal, which exactly fills that gap.</p><h2 id=overall-process>Overall Process<a hidden class=anchor aria-hidden=true href=#overall-process>#</a></h2><p>For instance, imagine you want to remove the avatar of a group chat in Monal, while on a slow, unreliable network.</p><ol><li>You submit the request, and the loading screen appears over the view (0:03)</li><li>Because the network is slow, the loading screen persists for a long time</li><li>You get frustrated and switch apps, sending Monal to the background (0:06)</li><li>After 30s in the background, Monal gets suspended (0:36)</li><li>The server fails to remove the avatar and sends an error to Monal</li><li>The response is handled by Monal‚Äôs app extension in the background (0:51)</li><li>You switch apps back to Monal (0:57)</li></ol><p>Without the promise framework, the app would have continued to show the loading screen indefinitely, requiring you to fully close and open the app.</p><p>However, with the promise framework, when you switch back to the app, the loading screen disappears and correctly shows the error returned by the server:</p><video preload=metadata style=max-height:32em controls>
<source src=/monal-im.org/site/post/00015-monal-internals-promise-framework/remove_avatar.mp4 type=video/mp4>Your browser does not support the video element.</video><p>The promise framework allows any such interaction, where the UI has to update in response from the server, to be handled in a general way.</p><h2 id=background>Background<a hidden class=anchor aria-hidden=true href=#background>#</a></h2><p>We will briefly describe the important parts below. But these links provide more detailed context and are recommended reading:</p><ul><li>The <a href=https://xmpp-meetup.in-berlin.de/talks/monal-and-push.pdf#Navigation6>app decomposition slides</a> explain the split between the main app and app extension.</li><li>The <a href=https://monal-im.github.io/monal-im.org/site/post/00007-monal-internals-handlers/#handlers>handler framework blog post</a> explores some of the consequences of this split.</li></ul><h3 id=main-app-and-app-extension>Main app and app extension<a hidden class=anchor aria-hidden=true href=#main-app-and-app-extension>#</a></h3><p>In Monal there are two separate processes: the ‚Äúmain app‚Äù (<code>MonalAppDelegate</code>) and ‚Äúapp extension‚Äù (<code>NotificationService</code>), which is sometimes abbreviated to ‚Äúappex‚Äù.</p><p>Since they do not share memory, they hand over to each other via the <a href=https://monal-im.github.io/monal-im.org/site/post/00007-monal-internals-handlers/#handlers>handler framework</a>.</p><p>An xmpp stanza can be processed by either, depending on whether the app is running or not:</p><p><img alt="Diagram showing that, if the app is active or in the background, stanzas get processed by the main app, otherwise they get processed by the appex, triggered by Apple&rsquo;s push servers if it is not already running" loading=lazy src=/monal-im.org/site/post/00015-monal-internals-promise-framework/stanza_processing.png></p><h3 id=app-states>App states<a hidden class=anchor aria-hidden=true href=#app-states>#</a></h3><p>Below is a slightly simplified diagram of the app‚Äôs lifecycle. A more detailed lifecycle from Apple‚Äôs perspective is <a href=https://developer.apple.com/documentation/uikit/managing-your-app-s-life-cycle>available here</a>.</p><p><img alt="Diagram showing the different states the app can be in. It is a visual depiction of the description below" loading=lazy src=/monal-im.org/site/post/00015-monal-internals-promise-framework/app_states.png></p><table><thead><tr><th>State</th><th>Description</th></tr></thead><tbody><tr><td>App not running</td><td>App is not running, and when it is opened, it will start afresh</td></tr><tr><td>App active</td><td>App is open and in the foreground</td></tr><tr><td>App in background</td><td>App is running, but in the background</td></tr><tr><td>App suspended</td><td>App is not running, but its state is saved for when the app is reopened</td></tr></tbody></table><ul><li>The app moves from &ldquo;active&rdquo; to &ldquo;in background&rdquo; when it is swiped away without being closed<ul><li>It continues to run and process stanzas for ~30s in the background</li></ul></li><li>Once the 30s are complete, it moves to &ldquo;suspended&rdquo;<ul><li>Apple saves the UI&rsquo;s state</li><li>When the app is reopened, it returns to the same screen as before</li><li>Any stanzas that were processed in the meantime were processed by the appex</li></ul></li></ul><h4 id=appex-states>Appex states<a hidden class=anchor aria-hidden=true href=#appex-states>#</a></h4><p>Meanwhile, the appex has a more simple lifecycle - it is either running, or not running:</p><p><img alt="Diagram showing that the appex can be in two states: &ldquo;running&rdquo; or &ldquo;not running&rdquo;. It moves to &ldquo;running&rdquo; state on receipt of a notification, then returns to &ldquo;not running&rdquo; state after 30s have passed" loading=lazy src=/monal-im.org/site/post/00015-monal-internals-promise-framework/appex_states.png></p><ul><li>Once the appex starts, it will connect to the server and run for 30s</li><li>If the app is opened while the appex is running, the appex will return to &ldquo;not running&rdquo; state in deference to the app.</li></ul><h2 id=serializable-promise-framework-1>Serializable promise framework<a hidden class=anchor aria-hidden=true href=#serializable-promise-framework-1>#</a></h2><p>Ok, now the background is out of the way, time to explain the promise framework!</p><p>While promises are very useful in SwiftUI, there is one problem: they only exist in that particular process, and cannot easily be passed between the app and appex.</p><p>This means that, if the promise was resolved in the appex, once the app is reopened (moves from suspended to active), it will not be consumed. This is because the appex has no way of tying the result back to the promise that updates the UI.</p><p>Since the handler framework is what allows the seamless handoff between the app and appex, we need a way to trigger consumption of a promise as a result of processing in the handler. This is precisely what the promise framework does!</p><h3 id=high-level-overview>High-level overview<a hidden class=anchor aria-hidden=true href=#high-level-overview>#</a></h3><p>We create a &ldquo;serializable promise&rdquo; class called <code>MLPromise</code>. This class stores a &ldquo;UI promise&rdquo; which is an <code>AnyPromise</code> from PromiseKit. Consumption of this <code>AnyPromise</code> is what ultimately causes the UI to update.</p><p>Whenever we want to bind a UI action to the result of a handler, we create an <code>MLPromise</code> and pass it as an argument to the handler. We then return the <code>MLPromise</code>&rsquo;s <code>AnyPromise</code> to the UI.</p><p>Unlike the <code>AnyPromise</code> it contains, the <code>MLPromise</code> is (mostly) serializable. When the <code>MLPromise</code> is created, and whenever it is resolved, it <a href=https://github.com/monal-im/Monal/blob/c20c9f9968109f0652bf640804b852f143bd5000/Monal/Classes/DataLayer.m#L2542-L2553>persists itself</a> to a <a href=https://github.com/monal-im/Monal/blob/c20c9f9968109f0652bf640804b852f143bd5000/Monal/Classes/DataLayerMigrations.m#L1153-L1156>new <code>promises</code> table</a> in the database.</p><p>Meanwhile, whenever the app or appex is unfrozen, and <a href=https://github.com/monal-im/Monal/blob/c20c9f9968109f0652bf640804b852f143bd5000/Monal/Classes/MLPromise.m#L49-L56>the promise table is read into memory</a>, the resolved arguments of any already existing promises are overwritten.</p><p>Note that <a href=https://github.com/monal-im/Monal/blob/c20c9f9968109f0652bf640804b852f143bd5000/Monal/Classes/MLPromise.m#L168-L173>this persisted version of the <code>MLPromise</code> is not complete</a> - while the resolved argument can be persisted, the UI promise is not persisted at any stage.</p><p>This means that, while the resolved argument can be passed betwen the app and appex, the UI promise itself cannot. The consequence of this is that a promise cannot be consumed in the appex - it can only be resolved there, leaving consumption for when the app becomes active again:</p><table><thead><tr><th>Process</th><th>Can resolve?</th><th>Can consume?</th></tr></thead><tbody><tr><td>App</td><td>Yes</td><td>Yes</td></tr><tr><td>Appex</td><td>Yes</td><td>No</td></tr></tbody></table><p>This makes some sense, as the whole purpose of the <code>AnyPromise</code> is to update the UI as a result of some backend action. It only makes sense to update the UI from the process which manages the UI - the app itself.</p><p>As a result, whenever the app becomes active again, all outstanding <code>MLPromise</code>s check the version retrieved from the DB if they have been resolved in the meantime, <a href=https://github.com/monal-im/Monal/blob/c20c9f9968109f0652bf640804b852f143bd5000/Monal/Classes/MLPromise.m#L77>and if so, consume themselves</a>. This is how the loading overlay gets removed in the above example.</p><h3 id=step-by-step-overview>Step-by-step overview<a hidden class=anchor aria-hidden=true href=#step-by-step-overview>#</a></h3><p>Let&rsquo;s return to the initial scenario of removing the avatar of a group chat. The user chooses the new avatar and presses submit. Then, the following happens:</p><p><img alt="Diagram showing the flow of promises throughout the app, as explained in detail below" loading=lazy src=/monal-im.org/site/post/00015-monal-internals-promise-framework/promises_flow.png></p><h4 id=1-ui-code-calls-backend><a href=https://github.com/monal-im/Monal/blob/c20c9f9968109f0652bf640804b852f143bd5000/Monal/Classes/ContactDetails.swift#L146-L148>(1) UI code calls backend</a><a hidden class=anchor aria-hidden=true href=#1-ui-code-calls-backend>#</a></h4><p>The UI code responding to requests to remove the avatar calls the backend method to do this.</p><p>Once the backend function completes, it will return an <code>AnyPromise</code>, allowing the UI code to continue immediately:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>showPromisingLoadingOverlay(overlay, headlineView:Text(<span style=color:#e6db74>&#34;Removing avatar...&#34;</span>), descriptionView:Text(<span style=color:#e6db74>&#34;&#34;</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// this returns an AnyPromise used by the loading overly to hide itself once it gets resolved</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>self</span>.account.mucProcessor.publishAvatar(<span style=color:#66d9ef>nil</span>, forMuc: contact.contactJid)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=2-core-code-creates-promise><a href=https://github.com/monal-im/Monal/blob/c20c9f9968109f0652bf640804b852f143bd5000/Monal/Classes/MLMucProcessor.m#L1292>(2) Core code creates promise</a><a hidden class=anchor aria-hidden=true href=#2-core-code-creates-promise>#</a></h4><p>The core code creates an <code>MLPromise</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>-(AnyPromise<span style=color:#f92672>*</span>) <span style=color:#a6e22e>publishAvatar:</span>(UIImage<span style=color:#f92672>*</span> _Nullable) image <span style=color:#a6e22e>forMuc:</span>(NSString<span style=color:#f92672>*</span>) room
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    MLPromise<span style=color:#f92672>*</span> promise <span style=color:#f92672>=</span> [MLPromise new];
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span></code></pre></div><h4 id=3-core-code-creates-handler-and-4-sends-iq><a href=https://github.com/monal-im/Monal/blob/c20c9f9968109f0652bf640804b852f143bd5000/Monal/Classes/MLMucProcessor.m#L1299>(3) Core code creates handler and (4) sends IQ</a><a hidden class=anchor aria-hidden=true href=#3-core-code-creates-handler-and-4-sends-iq>#</a></h4><p>The core code creates a new handler, and passes the <code>MLPromise</code> to it as an argument. Recall that <a href=https://github.com/monal-im/Monal/wiki/Handler-Framework>handlers serialize their arguments</a> - this means that, even if the app is suspended and the handler is called in the appex, the <code>MLPromise</code> will be available.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>[_account sendIq:vcard withHandler:<span style=color:#960050;background-color:#1e0010>$</span>newHandlerWithInvalidation(self, handleAvatarPublishResult, handleAvatarPublishResultInvalidation, <span style=color:#960050;background-color:#1e0010>$</span>ID(room), <span style=color:#960050;background-color:#1e0010>$</span>ID(promise))];
</span></span></code></pre></div><h4 id=5-promise-returned-to-ui><a href=https://github.com/monal-im/Monal/blob/c20c9f9968109f0652bf640804b852f143bd5000/Monal/Classes/MLMucProcessor.m#L1300>(5) Promise returned to UI</a><a hidden class=anchor aria-hidden=true href=#5-promise-returned-to-ui>#</a></h4><p>Internally, the <code>MLPromise</code> has created an <code>AnyPromise</code>. This is a type provided by PromiseKit that can be returned directly to the UI, and that the SwiftUI code understands. It gets returned to the UI code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#66d9ef>return</span> [promise toAnyPromise];
</span></span></code></pre></div><h4 id=6-xmpp-server-provides-response>(6) XMPP server provides response<a hidden class=anchor aria-hidden=true href=#6-xmpp-server-provides-response>#</a></h4><p>This happens on the server side and is not relevant to Monal.</p><p>However, while waiting for the response, the user puts the app into the background, and the app gets suspended.</p><h4 id=7-handler-resolves-promise><a href=https://github.com/monal-im/Monal/blob/c20c9f9968109f0652bf640804b852f143bd5000/Monal/Classes/MLMucProcessor.m#L1330>(7) Handler resolves promise</a><a hidden class=anchor aria-hidden=true href=#7-handler-resolves-promise>#</a></h4><p>Now, the response from the server activates the appex, since the app was suspended.</p><p>The handler is called with the response from the server. It resolves the promise (via either <code>reject</code> or <code>fulfill</code>) - passing that response to the promise.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$$</span>instance_handler(handleAvatarPublishResult, account.mucProcessor, <span style=color:#960050;background-color:#1e0010>$$</span>ID(xmpp<span style=color:#f92672>*</span>, account), <span style=color:#960050;background-color:#1e0010>$$</span>ID(XMPPIQ<span style=color:#f92672>*</span>, iqNode), <span style=color:#960050;background-color:#1e0010>$$</span>ID(MLPromise<span style=color:#f92672>*</span>, promise))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>([iqNode check:<span style=color:#e6db74>@&#34;/&lt;type=error&gt;&#34;</span>])
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span>        [promise reject:error];
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span>    [promise fulfill:nil];
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$$</span>
</span></span></code></pre></div><h4 id=8-promise-waits-until-app-is-open><a href=https://github.com/monal-im/Monal/blob/c20c9f9968109f0652bf640804b852f143bd5000/Monal/Classes/MLPromise.m#L42>(8) Promise waits until app is open</a><a hidden class=anchor aria-hidden=true href=#8-promise-waits-until-app-is-open>#</a></h4><p>If the promise had been resolved from the app, it could have been consumed immediately. However, since it was resolved from the appex, the <code>AnyPromise</code> was not available to call at that time.</p><p>Therefore, the promise does not consume itself yet - it instead waits for the app to return to active state.</p><p>This waiting is performed by the following observer - whenever either the app or appex is unfrozen, the <code>deserialize</code> method is called:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>-(<span style=color:#66d9ef>instancetype</span>) <span style=color:#a6e22e>init</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span>    [[NSNotificationCenter defaultCenter] addObserver:self selector:<span style=color:#66d9ef>@selector</span>(deserialize) name:kMonalUnfrozen object:nil];
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>deserialize</code> calls <code>attemptConsume</code> on each run. <code>attemptConsume</code> checks if we are inside the appex (in which case we do not consume the promise), and only if we are inside the app does it consume the promise:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>-(<span style=color:#66d9ef>void</span>) <span style=color:#a6e22e>attemptConsume</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    DDLogDebug(<span style=color:#e6db74>@&#34;Intend to consume promise %@ with uuid %@ and argument %@&#34;</span>, self, self.uuid, self.resolvedArgument);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>([HelperTools isAppExtension])
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        DDLogDebug(<span style=color:#e6db74>@&#34;Not consuming promise %@ with uuid %@ as we are in the app extension&#34;</span>, self, self.uuid);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note that both <code>reject</code> and <code>fulfill</code> also call <code>attemptConsume</code> after resolving the promise. This would let the promise be consumed immediately if we are inside the app instead of the appex.</p><h4 id=9-promise-consumes-ui-promise><a href=https://github.com/monal-im/Monal/blob/c20c9f9968109f0652bf640804b852f143bd5000/Monal/Classes/MLPromise.m#L154>(9) Promise consumes UI promise</a><a hidden class=anchor aria-hidden=true href=#9-promise-consumes-ui-promise>#</a></h4><p>Once we progress past the checks in <code>attemptConsume</code>, we finally consume the promise by calling the <code>resolve</code> callback tied to the PromiseKit <code>AnyPromise</code> returned earlier. This in turn prompts the UI to hide the loading overlay.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>-(<span style=color:#66d9ef>void</span>) <span style=color:#a6e22e>attemptConsume</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span>    PMKResolver resolve <span style=color:#f92672>=</span> _resolvers[self.uuid];
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span>    resolve(self.resolvedArgument);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://monal-im.github.io/monal-im.org/site/>Monal</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=text/javascript src=https://monal-im.github.io/monal-im.org/site/js/main.min.416309f1329adbd311186e61f8f1d0b56d9c308752b71dd96914593d05ef8166.js integrity="sha256-QWMJ8TKa29MRGG5h+PHQtW2cMIdStx3ZaRRZPQXvgWY="></script></body></html>