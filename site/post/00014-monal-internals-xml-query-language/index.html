<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Monal Internals - XML Query Language | Monal</title>
<meta name=keywords content><meta name=description content="In this new series, I want to shine some light onto specific parts of Monal&rsquo;s internals. It&rsquo;s dedicated to programmers or people curious about how Monal works internally. If you want to give some feedback, feel free to send an email to thilo@monal-im.org
Other articles in this series:

Monal Internals - Handlers framework

The MLXMLNode methods
All incoming and outgoing XMPP stanzas are parsed to/from an instance of nested MLXMLNode elements.
This class therefore provides some methods for creating such elements as well as querying them.
In this chapter I want to briefly introduce some parts of the MLXMLNode interface before diving into our XML Query Language in the next chapter."><meta name=author content="Thilo Molitor"><link crossorigin=anonymous href=/monal-im.org/site/assets/css/stylesheet.1ae742f00bc5f2d0a3081012780dcc1b3bd5bedc9543ac834ee6c4a2376d6d05.css integrity="sha256-GudC8AvF8tCjCBASeA3MGzvVvtyVQ6yDTubEojdtbQU=" rel="preload stylesheet" as=style fetchpriority=high><link rel=apple-touch-icon sizes=57x57 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_5b0c0295e1bab5e9.png fetchpriority=medium><link rel=apple-touch-icon sizes=60x60 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_bd855cd23e1a48ce.png fetchpriority=medium><link rel=apple-touch-icon sizes=72x72 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_1fc0f762f9228515.png fetchpriority=medium><link rel=apple-touch-icon sizes=76x76 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_3223be4d2bf3028e.png fetchpriority=medium><link rel=apple-touch-icon sizes=114x114 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_f786675ca2f65f23.png fetchpriority=low><link rel=apple-touch-icon sizes=120x120 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_b3a91168b2b809d0.png fetchpriority=low><link rel=apple-touch-icon sizes=144x144 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_41ae3c1c7e5ffc24.png fetchpriority=low><link rel=apple-touch-icon sizes=152x152 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_d9713e10e873faae.png fetchpriority=low><link rel=apple-touch-icon sizes=180x180 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_41678b9825916aea.png fetchpriority=low><link rel=icon type=image/x-icon href=https://monal-im.github.io/monal-im.org/site/favicons/favicon.ico fetchpriority=medium><link rel=icon type=image/png sizes=16x16 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_1633be2aac3ef974.png fetchpriority=medium><link rel=icon type=image/png sizes=32x32 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_ff5399801940d2fa.png fetchpriority=medium><link rel=icon type=image/png sizes=96x96 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_6d52ec5851359f1b.png fetchpriority=low><link rel=icon type=image/png sizes=128x128 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_cffa87af319b1512.png fetchpriority=low><link rel=icon type=image/png sizes=196x196 href=https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_c9659d2b4cfe0669.png fetchpriority=low><link rel=mask-icon color=red href=favicons/safari-pinned-tab.svg fetchpriority=low><meta name=application-name content="Monal-IM"><meta name=msapplication-TileColor content="#FFFFFF"><meta name=msapplication-square70x70logo content="https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_8b476404c4bc313e.png" fetchpriority=medium><meta name=msapplication-TileImage content="https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_41ae3c1c7e5ffc24.png" fetchpriority=low><meta name=msapplication-square150x150logo content="https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_fc52121ad2bc6c42.png" fetchpriority=low><meta name=msapplication-square310x310logo content="https://monal-im.github.io/monal-im.org/site/favicons/logo_hu_b389285b3ae3d855.png" fetchpriority=low><meta property="og:title" content="Monal Internals - XML Query Language"><meta property="og:description" content="In this new series, I want to shine some light onto specific parts of Monal&rsquo;s internals. It&rsquo;s dedicated to programmers or people curious about how Monal works internally. If you want to give some feedback, feel free to send an email to thilo@monal-im.org
Other articles in this series:

Monal Internals - Handlers framework

The MLXMLNode methods
All incoming and outgoing XMPP stanzas are parsed to/from an instance of nested MLXMLNode elements.
This class therefore provides some methods for creating such elements as well as querying them.
In this chapter I want to briefly introduce some parts of the MLXMLNode interface before diving into our XML Query Language in the next chapter."><meta property="og:type" content="article"><meta property="og:url" content="https://monal-im.github.io/monal-im.org/site/post/00014-monal-internals-xml-query-language/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-09-09T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-07T07:20:42+02:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://monal-im.github.io/monal-im.org/site/post/"},{"@type":"ListItem","position":2,"name":"Monal Internals - XML Query Language","item":"https://monal-im.github.io/monal-im.org/site/post/00014-monal-internals-xml-query-language/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Monal Internals - XML Query Language","name":"Monal Internals - XML Query Language","description":"In this new series, I want to shine some light onto specific parts of Monal\u0026rsquo;s internals. It\u0026rsquo;s dedicated to programmers or people curious about how Monal works internally. If you want to give some feedback, feel free to send an email to thilo@monal-im.org\nOther articles in this series:\nMonal Internals - Handlers framework The MLXMLNode methods All incoming and outgoing XMPP stanzas are parsed to/from an instance of nested MLXMLNode elements. This class therefore provides some methods for creating such elements as well as querying them. In this chapter I want to briefly introduce some parts of the MLXMLNode interface before diving into our XML Query Language in the next chapter.\n","keywords":[],"articleBody":"In this new series, I want to shine some light onto specific parts of Monal‚Äôs internals. It‚Äôs dedicated to programmers or people curious about how Monal works internally. If you want to give some feedback, feel free to send an email to thilo@monal-im.org\nOther articles in this series:\nMonal Internals - Handlers framework The MLXMLNode methods All incoming and outgoing XMPP stanzas are parsed to/from an instance of nested MLXMLNode elements. This class therefore provides some methods for creating such elements as well as querying them. In this chapter I want to briefly introduce some parts of the MLXMLNode interface before diving into our XML Query Language in the next chapter.\nCreating an MLXMLNode There are several initializers for MLXMLNode:\n-(id) initWithElement:(NSString*) element; -(id) initWithElement:(NSString*) element andNamespace:(NSString*) xmlns; -(id) initWithElement:(NSString*) element andNamespace:(NSString*) xmlns withAttributes:(NSDictionary*) attributes andChildren:(NSArray*) children andData:(NSString* _Nullable) data; -(id) initWithElement:(NSString*) element withAttributes:(NSDictionary*) attributes andChildren:(NSArray*) children andData:(NSString* _Nullable) data; -(id) initWithElement:(NSString*) element andData:(NSString* _Nullable) data; -(id) initWithElement:(NSString*) element andNamespace:(NSString*) xmlns andData:(NSString* _Nullable) data; The initializers not taking a namespace argument will create XML nodes that automatically inherit the namespace of their containing node, once added to a tree of XML nodes.\nWhen nesting MLXMLNodes , it looks like this:\nMLXMLNode* exampleNode = [[MLXMLNode alloc] initWithElement:@\"credentials\" andNamespace:@\"urn:xmpp:extdisco:2\" withAttributes:@{} andChildren:@[ [[MLXMLNode alloc] initWithElement:@\"service\" withAttributes:@{ @\"type\": service[@\"type\"], @\"host\": service[@\"host\"], @\"port\": service[@\"port\"], } andChildren:@[] andData:nil] ] andData:nil] Querying a (possibly nested) MLXMLNode All XML queries are implemented as an interface of MLXMLNode as well. For XML queries this class has three different methods:\n-(NSArray*) find:(NSString* _Nonnull) queryString, ... NS_FORMAT_FUNCTION(1, 2); -(id) findFirst:(NSString* _Nonnull) queryString, ... NS_FORMAT_FUNCTION(1, 2); -(BOOL) check:(NSString* _Nonnull) queryString, ... NS_FORMAT_FUNCTION(1, 2); find: will return an NSArray listing all results matching your query, findFirst: will only return the first result of your query (or nil if the resulting NSArray was empty). This should be used, if you are certain that there should only be one element matching (or none at all). check: can be used to determine if find: would return an empty NSArray.\nAll three methods take a string argument possibly containing printf-style format specifiers including the %@ specifier as supported by NSString stringWithFormat: and a variable argument list for providing the values for these format specifiers.\nThe Query Language To query single values out of a complex XML stanza, we use a XML query language inspired by XPath, but not compatible with it. Instead, our language, as implemented in Monal, is a strict superset of Prosody‚Äôs query language as documented in Prosody‚Äôs documentation of util.stanza. This makes it possible to copy over queries from Prosody and directly use them in Monal without any modification.\nThe query language consists of a path followed by an optional extraction command and conversion command and is parsed by complex regular expressions in MLXMLNode.m. These regular expressions and the usage of the xml language throughout Monal were security audited in 2024.\nNote: If the following description talks about the find: method, the findFirst: and check: methods are automatically included.\nPath Segments The path is built of /-separated segments each representing an XML node, selected by either an XML namespace or an element name or both. The XML namespace is wrapped in { } and prefixes the element name. Each path segment is used to select all XML nodes matching the criteria listed in this path segment. The special wildcard value * for element name or namespace mean ‚Äúany namespace‚Äù or ‚Äúany element‚Äù.\nIf the namespace is omitted, the namespace of the parent node in the XML tree the query is acted upon is used (or * , if there is no parent node), see example 0. The namespace of the parent node is used even if the find: method is executed on a child XML node, see example 1. The element name can not be omitted and should be set to * if unknown.\nA path beginning with a / is called a rooted query. That means the following first path segment is to be used to select the node the find: method is called on, if the leading / is omitted, the first path segment is used to select the child nodes of the node the find: method is called on.\nNote: If using such a rooted query to access attributes, element names etc. of the XML node the whole query is acting upon, both the element name and namespace can be fully omitted and are automatically replaced by {*}*. This allows us to write queries like /@h|int\" or /@autojoin|bool.\nThe special path segment with element name .. not naming any namespace or other selection criteria (e.g. /../) will ascend one node in the XML node tree to the parent of the XML node that the query reached and apply the remaining query to this XML node. Thus using /{jabber:client}iq/{http://jabber.org/protocol/pubsub}pubsub/items/../../../@type will return the value of the type attribute on the root element (the {jabber:iq}iq).\nNote: Not using an extraction command (see the next chapter below) will return the matching MLXMLNodes as reference. Changing the attributes etc. of that reference will change the original MLXMLNode in the XML tree it is part of. If you don‚Äôt want that, you‚Äôll have to call copy on the returned MLXMLNodes to decouple them from their original.\nExample 0:\n","wordCount":"2404","inLanguage":"en","datePublished":"2024-09-09T00:00:00Z","dateModified":"2024-10-07T07:20:42+02:00","author":{"@type":"Person","name":"Thilo Molitor"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://monal-im.github.io/monal-im.org/site/post/00014-monal-internals-xml-query-language/"},"publisher":{"@type":"Organization","name":"Monal","logo":{"@type":"ImageObject","url":"https://monal-im.github.io/monal-im.org/site/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://monal-im.github.io/monal-im.org/site/ accesskey=h title="Monal (Alt + H)">Monal</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li class=menu-item><a href=/monal-im.org/site/install/ title=Install><span>Install</span></a></li><li class=menu-item><a href=/monal-im.org/site/support/ title=Support><span>Support</span></a></li><li class=menu-item><a href=/monal-im.org/site/post/ title=Blog><span>Blog</span></a></li><li class=menu-item><a href=/monal-im.org/site/publications/ title=Publications><span>Publications</span></a></li><li class=menu-item><a href=/monal-im.org/site/privacy/ title=Privacy><span>Privacy</span></a></li><li class=menu-item><a href=/monal-im.org/site/about/ title=About><span>About</span></a></li><li class=menu-item><a href=https://github.com/monal-im/Monal/wiki title=Wiki><span>Wiki</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li class=menu-item><a href=/monal-im.org/site/search/ title="Search üîç (Alt + /)" accesskey=/><span>Search üîç</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Monal Internals - XML Query Language</h1><div class=post-meta><span title='2024-09-09 00:00:00 +0000 UTC'>09.09.2024</span>&nbsp;¬∑&nbsp;12 min&nbsp;¬∑&nbsp;Thilo Molitor<a href=/index.xml rel="noopener noreferrer" target=_blank>&nbsp;RSS</a>&nbsp;|&nbsp;<a href=https://github.com/monal-im/monal-im.org/tree/staging/content/post/00014-monal-internals-xml-query-language.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>In this new series, I want to shine some light onto specific parts of Monal&rsquo;s internals. It&rsquo;s dedicated to programmers or people curious about how Monal works internally. If you want to give some feedback, feel free to send an email to <a href=mailto:thilo@monal-im.org>thilo@monal-im.org</a></p><p><strong>Other articles in this series:</strong></p><ul><li><a href=/monal-im.org/site/post/00007-monal-internals-handlers/>Monal Internals - Handlers framework</a></li></ul><h1 id=the-mlxmlnode-methods>The <code>MLXMLNode</code> methods<a hidden class=anchor aria-hidden=true href=#the-mlxmlnode-methods>#</a></h1><p>All incoming and outgoing XMPP stanzas are parsed to/from an instance of nested <code>MLXMLNode</code> elements.
This class therefore provides some methods for creating such elements as well as querying them.
In this chapter I want to briefly introduce some parts of the <code>MLXMLNode</code> interface before diving into our XML Query Language in the next chapter.</p><h2 id=creating-an-mlxmlnode>Creating an <code>MLXMLNode</code><a hidden class=anchor aria-hidden=true href=#creating-an-mlxmlnode>#</a></h2><p>There are several initializers for <code>MLXMLNode</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>-(<span style=color:#66d9ef>id</span>) <span style=color:#a6e22e>initWithElement:</span>(NSString<span style=color:#f92672>*</span>) element;
</span></span><span style=display:flex><span>-(<span style=color:#66d9ef>id</span>) <span style=color:#a6e22e>initWithElement:</span>(NSString<span style=color:#f92672>*</span>) element <span style=color:#a6e22e>andNamespace:</span>(NSString<span style=color:#f92672>*</span>) xmlns;
</span></span><span style=display:flex><span>-(<span style=color:#66d9ef>id</span>) <span style=color:#a6e22e>initWithElement:</span>(NSString<span style=color:#f92672>*</span>) element <span style=color:#a6e22e>andNamespace:</span>(NSString<span style=color:#f92672>*</span>) xmlns <span style=color:#a6e22e>withAttributes:</span>(NSDictionary<span style=color:#f92672>*</span>) attributes <span style=color:#a6e22e>andChildren:</span>(NSArray<span style=color:#f92672>*</span>) children <span style=color:#a6e22e>andData:</span>(NSString<span style=color:#f92672>*</span> _Nullable) data;
</span></span><span style=display:flex><span>-(<span style=color:#66d9ef>id</span>) <span style=color:#a6e22e>initWithElement:</span>(NSString<span style=color:#f92672>*</span>) element <span style=color:#a6e22e>withAttributes:</span>(NSDictionary<span style=color:#f92672>*</span>) attributes <span style=color:#a6e22e>andChildren:</span>(NSArray<span style=color:#f92672>*</span>) children <span style=color:#a6e22e>andData:</span>(NSString<span style=color:#f92672>*</span> _Nullable) data;
</span></span><span style=display:flex><span>-(<span style=color:#66d9ef>id</span>) <span style=color:#a6e22e>initWithElement:</span>(NSString<span style=color:#f92672>*</span>) element <span style=color:#a6e22e>andData:</span>(NSString<span style=color:#f92672>*</span> _Nullable) data;
</span></span><span style=display:flex><span>-(<span style=color:#66d9ef>id</span>) <span style=color:#a6e22e>initWithElement:</span>(NSString<span style=color:#f92672>*</span>) element <span style=color:#a6e22e>andNamespace:</span>(NSString<span style=color:#f92672>*</span>) xmlns <span style=color:#a6e22e>andData:</span>(NSString<span style=color:#f92672>*</span> _Nullable) data;
</span></span></code></pre></div><p>The initializers not taking a namespace argument will create XML nodes that automatically inherit the namespace of their containing node, once added to a tree of XML nodes.</p><p>When nesting <code>MLXMLNode</code>s , it looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>MLXMLNode<span style=color:#f92672>*</span> exampleNode <span style=color:#f92672>=</span> [[MLXMLNode alloc] initWithElement:<span style=color:#e6db74>@&#34;credentials&#34;</span> andNamespace:<span style=color:#e6db74>@&#34;urn:xmpp:extdisco:2&#34;</span> withAttributes:<span style=color:#ae81ff>@{}</span> andChildren:<span style=color:#ae81ff>@[</span>
</span></span><span style=display:flex><span>    [[MLXMLNode alloc] initWithElement:<span style=color:#e6db74>@&#34;service&#34;</span>  withAttributes:<span style=color:#ae81ff>@{</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>@&#34;type&#34;</span><span style=color:#f92672>:</span> service[<span style=color:#e6db74>@&#34;type&#34;</span>],
</span></span><span style=display:flex><span>        <span style=color:#e6db74>@&#34;host&#34;</span><span style=color:#f92672>:</span> service[<span style=color:#e6db74>@&#34;host&#34;</span>],
</span></span><span style=display:flex><span>        <span style=color:#e6db74>@&#34;port&#34;</span><span style=color:#f92672>:</span> service[<span style=color:#e6db74>@&#34;port&#34;</span>],
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>}</span> andChildren:<span style=color:#ae81ff>@[]</span> andData:nil]
</span></span><span style=display:flex><span><span style=color:#ae81ff>]</span> andData:nil]
</span></span></code></pre></div><h2 id=querying-a-possibly-nested-mlxmlnode>Querying a (possibly nested) <code>MLXMLNode</code><a hidden class=anchor aria-hidden=true href=#querying-a-possibly-nested-mlxmlnode>#</a></h2><p>All XML queries are implemented as an interface of <code>MLXMLNode</code> as well. For XML queries this class has three different methods:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>-(NSArray<span style=color:#f92672>*</span>) <span style=color:#a6e22e>find:</span>(NSString<span style=color:#f92672>*</span> _Nonnull) queryString, ... NS_FORMAT_FUNCTION(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>-(<span style=color:#66d9ef>id</span>) <span style=color:#a6e22e>findFirst:</span>(NSString<span style=color:#f92672>*</span> _Nonnull) queryString, ... NS_FORMAT_FUNCTION(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>-(<span style=color:#66d9ef>BOOL</span>) <span style=color:#a6e22e>check:</span>(NSString<span style=color:#f92672>*</span> _Nonnull) queryString, ... NS_FORMAT_FUNCTION(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>);
</span></span></code></pre></div><p><code>find:</code> will return an <code>NSArray</code> listing all results matching your query, <code>findFirst:</code> will only return the first result of your query (or nil if the resulting <code>NSArray</code> was empty). This should be used, if you are certain that there should only be one element matching (or none at all). <code>check:</code> can be used to determine if <code>find:</code> would return an empty <code>NSArray</code>.</p><p>All three methods take a string argument possibly containing <code>printf</code>-style format specifiers including the <code>%@</code> specifier as supported by <code>NSString stringWithFormat:</code> and a variable argument list for providing the values for these format specifiers.</p><h1 id=the-query-language>The Query Language<a hidden class=anchor aria-hidden=true href=#the-query-language>#</a></h1><p>To query single values out of a complex XML stanza, we use a XML query language inspired by XPath, but <strong>not</strong> compatible with it.
Instead, our language, as implemented in Monal, is a strict superset of Prosody&rsquo;s query language as documented in <a href=https://prosody.im/doc/developers/util/stanza#stanzafind_path>Prosody&rsquo;s documentation of util.stanza</a>. This makes it possible to copy over queries from Prosody and directly use them in Monal without any modification.</p><p>The query language consists of a <code>path</code> followed by an optional <code>extraction command</code> and <code>conversion command</code> and is parsed by complex regular expressions in <code>MLXMLNode.m</code>. These regular expressions and the usage of the xml language throughout Monal were <a href=https://monal-im.org/post/00011-security-audit-1/>security audited in 2024</a>.</p><p><strong><em>Note:</em></strong> If the following description talks about the <code>find:</code> method, the <code>findFirst:</code> and <code>check:</code> methods are automatically included.</p><h2 id=path-segments>Path Segments<a hidden class=anchor aria-hidden=true href=#path-segments>#</a></h2><p>The path is built of <code>/</code>-separated segments each representing an XML node, selected by either an XML namespace or an element name or both. The XML namespace is wrapped in <code>{ }</code> and prefixes the element name.
Each path segment is used to select all XML nodes matching the criteria listed in this path segment.
The special wildcard value <code>*</code> for element name or namespace mean &ldquo;any namespace&rdquo; or &ldquo;any element&rdquo;.</p><p>If the namespace is omitted, the namespace of the parent node in the XML tree the query is acted upon is used (or <code>* </code>, if there is no parent node), see <em>example 0</em>. The namespace of the parent node is used even if the <code>find:</code> method is executed on a child XML node, see <em>example 1</em>. The element name can not be omitted and should be set to <code>*</code> if unknown.</p><p>A path beginning with a <code>/</code> is called a <code>rooted query</code>. That means the following first path segment is to be used to select the node the <code>find:</code> method is called on, if the leading <code>/</code> is omitted, the first path segment is used to select the <strong>child nodes</strong> of the node the <code>find:</code> method is called on.</p><p><strong><em>Note:</em></strong> If using such a <code>rooted query</code> to access attributes, element names etc. of the XML node the whole query is acting upon, both the element name and namespace can be fully omitted and are automatically replaced by <code>{*}*</code>. This allows us to write queries like <code>/@h|int"</code> or <code>/@autojoin|bool</code>.</p><p>The special path segment with element name <code>..</code> not naming any namespace or other selection criteria (e.g. <code>/../</code>) will ascend one node in the XML node tree to the parent of the XML node that the query reached and apply the remaining query to this XML node. Thus using <code>/{jabber:client}iq/{http://jabber.org/protocol/pubsub}pubsub/items/../../../@type</code> will return the value of the type attribute on the root element (the <code>{jabber:iq}iq</code>).</p><p><strong><em>Note:</em></strong> Not using an extraction command (see the next chapter below) will return the matching <code>MLXMLNode</code>s <em>as reference</em>. Changing the attributes etc. of that reference will change the original <code>MLXMLNode</code> in the XML tree it is part of.
If you don&rsquo;t want that, you&rsquo;ll have to call <code>copy</code> on the returned <code>MLXMLNode</code>s to decouple them from their original.</p><p><strong>Example 0:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;message</span> <span style=color:#a6e22e>from=</span><span style=color:#e6db74>&#39;test@example.org&#39;</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#39;some_id&#39;</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;jabber:client&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;body&gt;</span>Message text<span style=color:#f92672>&lt;/body&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;body</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:some:different:namespace&#39;</span><span style=color:#f92672>&gt;</span>This will NOT be used<span style=color:#f92672>&lt;/body&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/message&gt;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>MLXMLNode<span style=color:#f92672>*</span> message <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>the stanza above as MLXMLNode tree<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>NSArray<span style=color:#f92672>&lt;</span>NSString<span style=color:#f92672>*&gt;*</span> bodyStrings <span style=color:#f92672>=</span> [message find:<span style=color:#e6db74>@&#34;body#&#34;</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MLAssert(bodyStrings.count <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>@&#34;Only one body text should be returned!&#34;</span>);
</span></span><span style=display:flex><span>MLAssert([bodyStrings[<span style=color:#ae81ff>0</span>] isEqualToString:<span style=color:#e6db74>@&#34;Message text&#34;</span>, <span style=color:#e6db74>@&#34;The body with inherited namespace &#39;jabber:client&#39; should be used!&#34;</span>);
</span></span></code></pre></div><p><strong>Example 1:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;message</span> <span style=color:#a6e22e>from=</span><span style=color:#e6db74>&#39;test@example.org&#39;</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#39;some_id&#39;</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;jabber:client&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;body&gt;</span>Message text<span style=color:#f92672>&lt;/body&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/message&gt;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>MLXMLNode<span style=color:#f92672>*</span> message <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>the stanza above as MLXMLNode tree<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>NSString<span style=color:#f92672>*</span> messageId <span style=color:#f92672>=</span> [message findFirst:<span style=color:#e6db74>@&#34;/@id&#34;</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MLAssert([messageId isEqualToString:<span style=color:#e6db74>@&#34;some_id&#34;</span>, <span style=color:#e6db74>@&#34;The extracted message id should be &#39;some_id&#39;!&#34;</span>);
</span></span></code></pre></div><h3 id=more-selection-criteria>More selection criteria<a hidden class=anchor aria-hidden=true href=#more-selection-criteria>#</a></h3><ul><li><strong>Not element name:</strong><br>If you want to select all XML nodes <strong>not</strong> having a specified name, you&rsquo;ll have to prefix the element name with <code>!</code>. This will negate the selection, e.g. <code>!text</code> will select all XML nodes <strong>not</strong> named <code>text</code>, see <em>example 2</em>.</li><li><strong>Element attribute equals value</strong>:<br>If you want to select XML nodes on the basis of their XML attributes, you can list those attributes as <code>attributeName=value</code> pairs each inside <code>&lt; ></code>, see <em>example 3</em>. You can use format string specifiers in the value part of those pairs to replace those with the variadic arguments of <code>find:</code>. The order of variadic arguments has to resemble <em>all</em> format specifiers of the complete query string given to <code>find:</code> Note: the value part of those pairs can not be omitted, use regular expression matching to select for mere XML attribute presence (e.g. <code>&lt;attributeName~^.*$></code>).</li><li><strong>Element attribute matches regular expression</strong>:<br>To select XML nodes on the basis of their XML attributes, but using a regular expression, you&rsquo;ll have to use <code>attributeName~regex</code> pairs inside <code>&lt; ></code>. No format string specifiers will be replaced inside your regular expression following the <code>~</code>. You&rsquo;ll have to use <code>^</code> and <code>$</code> to match begin and end of the attribute value yourself, e.g. <code>&lt;attributeName~.></code> will match all attribute values having <strong>at least</strong> one character, while <code>&lt;attributeName~^.$></code> will match all attribute values having <strong>exactly</strong> one character.</li></ul><p><strong>Example 2:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;stream:error&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;not-well-formed</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:ietf:params:xml:ns:xmpp-streams&#39;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;text</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:ietf:params:xml:ns:xmpp-streams&#39;</span><span style=color:#f92672>&gt;</span>Some descriptive Text...<span style=color:#f92672>&lt;/text&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/stream:error&gt;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>MLXMLNode<span style=color:#f92672>*</span> streamError <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>the stanza above as MLXMLNode tree<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>NSString<span style=color:#f92672>*</span> errorReason <span style=color:#f92672>=</span> [streamError findFirst:<span style=color:#e6db74>@&#34;{urn:ietf:params:xml:ns:xmpp-streams}!text$&#34;</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MLAssert([errorReason isEqualToString:<span style=color:#e6db74>@&#34;not-well-formed&#34;</span>], <span style=color:#e6db74>@&#34;The extracted error should be &#39;not-well-formed&#39;!&#34;</span>);
</span></span></code></pre></div><p><strong>Example 3 (also using an extraction command, see below):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;iq</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#39;605818D4-4D16-4ACC-B003-BFA3E11849E1&#39;</span> <span style=color:#a6e22e>to=</span><span style=color:#e6db74>&#39;user@example.com/Monal-iOS.15e153a8&#39;</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;jabber:client&#39;</span> <span style=color:#a6e22e>type=</span><span style=color:#e6db74>&#39;result&#39;</span> <span style=color:#a6e22e>from=</span><span style=color:#e6db74>&#39;asdkjfhskdf@messaging.one&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;pubsub</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;http://jabber.org/protocol/pubsub&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;subscription</span> <span style=color:#a6e22e>node=</span><span style=color:#e6db74>&#39;eu.siacs.conversations.axolotl.devicelist&#39;</span> <span style=color:#a6e22e>subid=</span><span style=color:#e6db74>&#39;6795F13596465&#39;</span> <span style=color:#a6e22e>subscription=</span><span style=color:#e6db74>&#39;subscribed&#39;</span> <span style=color:#a6e22e>jid=</span><span style=color:#e6db74>&#39;user@example.com&#39;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/pubsub&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/iq&gt;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>MLXMLNode<span style=color:#f92672>*</span> iq <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>the stanza above as MLXMLNode tree<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>NSString<span style=color:#f92672>*</span> subscriptionStatus <span style=color:#f92672>=</span> [iq findFirst:<span style=color:#e6db74>@&#34;/&lt;type=result&gt;/{http://jabber.org/protocol/pubsub}pubsub/subscription&lt;node=%@&gt;&lt;jid=%@&gt;@subscription&#34;</span>, <span style=color:#e6db74>@&#34;eu.siacs.conversations.axolotl.devicelist&#34;</span>, <span style=color:#e6db74>@&#34;user@example.com&#34;</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MLAssert([subscriptionStatus isEqualToString:<span style=color:#e6db74>@&#34;subscribed&#34;</span>], <span style=color:#e6db74>@&#34;The extracted value of the subscription attribute should be &#39;subscribed&#39;!&#34;</span>);
</span></span></code></pre></div><h2 id=extraction-commands>Extraction Commands<a hidden class=anchor aria-hidden=true href=#extraction-commands>#</a></h2><p>An extraction command can be appended to the last path segment. Without those extraction commands, <code>find:</code> will return the full <code>MLXMLNode</code> matching the selection criteria of the XML query. If you rather want to read a special attribute, element value etc. of the full XML node, you&rsquo;ll have to use one of the extractions commands below</p><ul><li><code>@attributeName</code>:<br>This will return the value of the attribute named after the <code>@</code> as <code>NSString</code>, use a conversion command to convert the value to other data types.</li><li><code>@@</code>:
This will return all attributes of the selected XML node as key-value-pairs in an <code>NSDictionary</code>. No conversion commands can be used together with this extraction command.</li><li><code>#</code>:
This will return the text contents of the selected XML node as <code>NSString</code>, use a conversion command to convert the value to other data types.</li><li><code>$</code>:
This will return the element name of the selected XML node as <code>NSString</code>. This is only really useful if the last path segment contained a wildcard element name or its element name was negated. A Conversion command can be used to convert the returned element name to other data types as well.</li></ul><p>For data-form (<a href=https://xmpp.org/extensions/xep-0004.html>XEP-0004</a>) subqueries, see the corresponding section below.</p><h2 id=conversion-commands>Conversion Commands<a hidden class=anchor aria-hidden=true href=#conversion-commands>#</a></h2><p>Conversion commands can be used to convert the returned <code>NSString</code> of an extraction command to some other data type. Conversion commands can not be used without an extraction command and must be separated from the preceeding extraction command by a pipe symbol (<code>|</code>).
The following conversions are currently defined:</p><ul><li><code>bool</code>:<br>This will convert the extracted <code>NSString</code> to an <code>NSNumber</code> representing a <code>BOOL</code>. <code>true</code>/<code>1</code> becomes <code>@YES</code> and <code>false</code>/<code>0</code> becomes <code>@NO</code>. This is in accordance to the representation of truth values in XMPP.</li><li><code>int</code>:<br>This will convert the extracted <code>NSString</code> to an <code>NSNumber</code> representing a <code>NSInteger</code> (<code>integerValue</code> property).</li><li><code>uint</code>:<br>This will convert the extracted <code>NSString</code> to an <code>NSNumber</code> representing a <code>NSUInteger</code> (<code>unsignedIntegerValue</code> property).</li><li><code>double</code>:<br>This will convert the extracted <code>NSString</code> to an <code>NSNumber</code> representing a <code>double</code> (<code>doubleValue</code> property).</li><li><code>datetime</code>:<br>This will use the <code>HelperTools</code> method <code>parseDateTimeString:</code> to parse the given <code>NSString</code> into an <code>NSDate</code> object.</li><li><code>base64</code>:<br>This will use the <code>HelperTools</code> method <code>dataWithBase64EncodedString:</code> to parse the given <code>NSString</code> into an <code>NSData</code> object.</li><li><code>uuid</code>:<br>This will try to parse the given <code>NSString</code> into an <code>NSUUID</code> object using the <code>initWithUUIDString</code> initializer of <code>NSUUID</code>. This will return <code>nil</code> for an invalid string, which will omit this result from the <code>NSArray</code> returned by <code>find:</code> (<code>findFirst:</code> will return nil, and <code>check:</code> will return NO).</li><li><code>uuidcast</code>:<br>This will do the same as the <code>uuid</code> conversion command for valid uuid strings, but use the <code>HelperTools</code>method <code>stringToUUID</code> to cast any other given string to a UUIDv4 by hashing it using SHA256 and arranging the result to resemble a valid UUIDv4.</li></ul><p><strong>Example 4 (attribute extraction command together with a <code>bool</code> conversion command):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;iq</span> <span style=color:#a6e22e>type=</span><span style=color:#e6db74>&#39;result&#39;</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#39;juliet1&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;fin</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:mam:2&#39;</span> <span style=color:#a6e22e>complete=</span><span style=color:#e6db74>&#39;true&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;set</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;http://jabber.org/protocol/rsm&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;first</span> <span style=color:#a6e22e>index=</span><span style=color:#e6db74>&#39;0&#39;</span><span style=color:#f92672>&gt;</span>28482-98726-73623<span style=color:#f92672>&lt;/first&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;last&gt;</span>09af3-cc343-b409f<span style=color:#f92672>&lt;/last&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/set&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/fin&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/iq&gt;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>MLXMLNode<span style=color:#f92672>*</span> iqNode <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>the stanza above as MLXMLNode tree<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>([[iqNode findFirst:<span style=color:#e6db74>@&#34;{urn:xmpp:mam:2}fin@complete|bool&#34;</span>] boolValue])
</span></span><span style=display:flex><span>    DDLogInfo(<span style=color:#e6db74>@&#34;Mam query finished&#34;</span>)
</span></span></code></pre></div><p><strong>Example 5 (attribute extraction command together with a <code>datetime</code> conversion command):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;message</span> <span style=color:#a6e22e>from=</span><span style=color:#e6db74>&#39;romeo@montague.net/orchard&#39;</span> <span style=color:#a6e22e>to=</span><span style=color:#e6db74>&#39;juliet@capulet.com&#39;</span> <span style=color:#a6e22e>type=</span><span style=color:#e6db74>&#39;chat&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;body&gt;</span>O blessed, blessed night! I am afeard.<span style=color:#f92672>&lt;/body&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;delay</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:delay&#39;</span> <span style=color:#a6e22e>from=</span><span style=color:#e6db74>&#39;capulet.com&#39;</span> <span style=color:#a6e22e>stamp=</span><span style=color:#e6db74>&#39;2002-09-10T23:08:25Z&#39;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/message&gt;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>MLXMLNode<span style=color:#f92672>*</span> messageNode <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>the stanza above as MLXMLNode tree<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>NSDate<span style=color:#f92672>*</span> delayStamp <span style=color:#f92672>=</span> [messageNode findFirst:<span style=color:#e6db74>@&#34;{urn:xmpp:delay}delay@stamp|datetime&#34;</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MLAssert(delayStamp.timeIntervalSince1970 <span style=color:#f92672>==</span> <span style=color:#ae81ff>1031699305</span>, @The delay stamp should be <span style=color:#ae81ff>1031699305</span> seconds after the epoch<span style=color:#f92672>!</span><span style=color:#e6db74>&#34;);</span>
</span></span></code></pre></div><p><strong>Some more queries as found in our codebase:</strong></p><ul><li><code>{urn:xmpp:jingle:1}jingle&lt;action~^session-(initiate|accept)$></code></li><li><code>error/{urn:ietf:params:xml:ns:xmpp-stanzas}item-not-found</code></li><li><code>{urn:xmpp:avatar:metadata}metadata/info</code></li><li><code>{urn:xmpp:avatar:data}data#|base64</code></li></ul><h1 id=the-data-forms-xep-0004-query-language-extension>The data-forms (XEP-0004) query language extension<a hidden class=anchor aria-hidden=true href=#the-data-forms-xep-0004-query-language-extension>#</a></h1><p>To query fields etc. of a <a href=https://xmpp.org/extensions/xep-0004.html>XEP-0004</a> data-form, the last path segment of an XML query can contain a data-forms subquery.
Thes parser for these subqueries is an <code>MLXMLNode</code> extension implemented in <code>XMPPDataForm.m</code> and glued into <code>MLXMLNode.m</code> as the extraction command <code>\</code> (backslash). This extraction command is also special as it has to be terminated by a <code>\</code> (optionally followed by a conversion command, see below).</p><p><strong><em>Note:</em></strong> since our query is a string, double backslashes (<code>\\</code>) have to be used because of string escaping rules.</p><p>Like other extraction commands, these subqueries must be in the last path segment. Naming the element name and namespace of the node this extraction command is applied to, is optional and automatically defaults to name <code>x</code> and namespace <code>jabber:x:data</code> as defined by <a href=https://xmpp.org/extensions/xep-0004.html>XEP-0004</a>.</p><p>This query language extension is its own small query language tailored to data-forms implemented in <code>-(id _Nullable) processDataFormQuery:(NSString*) query;</code>.
To ease its use, this language reuses some constructs of the main query language, but gives them a new meaning:</p><ul><li><strong>&ldquo;Namespace&rdquo; and &ldquo;element name&rdquo;:</strong><br>The subquery can begin with something looking like a namespace and element name (both optional) like so: <code>{http://jabber.org/protocol/muc#roominfo}result</code>. The &ldquo;element name&rdquo; is used to select data forms with this form-type (<code>result</code> in this case). The &ldquo;namespace&rdquo; is used to select data-forms with a form field (usually of type hidden) with name <code>FORM_TYPE</code> having this value, see <em>example 6</em>. The special form-type <code>*</code> and <code>FORM_TYPE</code> value <code>*</code> can be used to denote &ldquo;any form-type&rdquo; and &ldquo;any FORM_TYPE field value&rdquo;.</li><li><strong>Item index:</strong><br>This is something not present in the main query language. Between the form-type (the &ldquo;element name&rdquo;, see above) and the &ldquo;extraction command&rdquo; (see below) an index in square brackets is allowed (<code>[0]</code>). An example query using an index as seen in our codebase would be <code>\\result[0]@expire\\</code> or <code>\\[0]@expire\\</code>. An index is only allowed for data-forms having multiple item elements encapsulating the form fields, see <a href=https://xmpp.org/extensions/xep-0004.html#example-8>example 8 of XEP-0004</a>. If the index is out of bounds (e.g. greater than or equal to the count of <code>&lt;item/></code> XML nodes in the form), the data-form query will return nil, which will be omitted from the resulting <code>NSArray</code> by the <code>MLXMLNode</code> implementation of <code>find:</code> (<code>findFirst:</code> will return nil, and <code>check:</code> will return NO).</li><li><strong>Extraction command:</strong><br>Data-Form subqueries have only two extraction commands: <code>@fieldName</code> and <code>&amp;fieldName</code>. <code>@fieldName</code> is used to extract the value of that field, while <code>&amp;fieldName</code> returns an <code>NSDictionary</code> describing that field, like returned with the <code>-(NSDictionary* _Nullable) getField:(NSString* _Nonnull) name;</code> method of <code>XMPPDataForm</code>.</li></ul><p><strong><em>Note:</em></strong> The implementation in <code>XMPPDataForm.m</code> has many useful methods for creating and working with <a href=https://xmpp.org/extensions/xep-0004.html>XEP-0004</a> data-forms. Make sure to check out <code>XMPPDataForm.h</code> or the implementation in <code>XMPPDataForm.m</code>.</p><p><strong><em>Note:</em></strong> An <code>@fieldName</code> extraction command can be used together with a conversion command, see <em>example 6</em>. Conversion commands are not allowed for <code>&amp;fieldName</code> extraction commands or data-form queries not using an extraction command at all (e.g. returning the whole data-form).</p><p><strong>Example 6:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;iq</span> <span style=color:#a6e22e>from=</span><span style=color:#e6db74>&#39;upload.montague.tld&#39;</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#39;step_02&#39;</span> <span style=color:#a6e22e>to=</span><span style=color:#e6db74>&#39;romeo@montague.tld/garden&#39;</span> <span style=color:#a6e22e>type=</span><span style=color:#e6db74>&#39;result&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;query</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;http://jabber.org/protocol/disco#info&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;identity</span> <span style=color:#a6e22e>category=</span><span style=color:#e6db74>&#39;store&#39;</span> <span style=color:#a6e22e>type=</span><span style=color:#e6db74>&#39;file&#39;</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#39;HTTP File Upload&#39;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;feature</span> <span style=color:#a6e22e>var=</span><span style=color:#e6db74>&#39;urn:xmpp:http:upload:0&#39;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;x</span> <span style=color:#a6e22e>type=</span><span style=color:#e6db74>&#39;result&#39;</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;jabber:x:data&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;field</span> <span style=color:#a6e22e>var=</span><span style=color:#e6db74>&#39;FORM_TYPE&#39;</span> <span style=color:#a6e22e>type=</span><span style=color:#e6db74>&#39;hidden&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;value&gt;</span>urn:xmpp:http:upload:0<span style=color:#f92672>&lt;/value&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;/field&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;field</span> <span style=color:#a6e22e>var=</span><span style=color:#e6db74>&#39;max-file-size&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;value&gt;</span>5242880<span style=color:#f92672>&lt;/value&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;/field&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/x&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/query&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/iq&gt;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>MLXMLNode<span style=color:#f92672>*</span> iqNode <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>the stanza above as MLXMLNode tree<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>NSInteger uploadSize <span style=color:#f92672>=</span> [[iqNode findFirst:<span style=color:#e6db74>@&#34;{http://jabber.org/protocol/disco#info}query/</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>{urn:xmpp:http:upload:0}result@max-file-size</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>|int&#34;</span>] integerValue];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MLAssert(uploadSize <span style=color:#f92672>==</span> <span style=color:#ae81ff>5242880</span>, <span style=color:#e6db74>@&#34;Extracted upload size should be 5242880 bytes!&#34;</span>);
</span></span></code></pre></div><p><strong>Some more data-form queries as found in our codebase:</strong></p><ul><li><code>{http://jabber.org/protocol/disco#info}query/\\{http://jabber.org/protocol/muc#roominfo}result@muc#roomconfig_roomname\\</code></li><li><code>{http://jabber.org/protocol/commands}command&lt;node=urn:xmpp:invite#invite>/\\[0]@expire\\|datetime</code> (the form-type and FORM_TYPE field value was omitted, the query matches every data-form)</li><li><code>{http://jabber.org/protocol/commands}command&lt;node=urn:xmpp:invite#invite>/\\@expire\\|datetime</code> (the form-type and FORM_TYPE field value was omitted, the query matches every data-form)</li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://monal-im.github.io/monal-im.org/site/>Monal</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=text/javascript src=https://monal-im.github.io/monal-im.org/site/js/main.min.416309f1329adbd311186e61f8f1d0b56d9c308752b71dd96914593d05ef8166.js integrity="sha256-QWMJ8TKa29MRGG5h+PHQtW2cMIdStx3ZaRRZPQXvgWY="></script></body></html>