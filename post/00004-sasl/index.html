<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>On the state of SASL in XMPP | Monal</title><meta name=keywords content><meta name=description content="SASL (Simple Authentication and Security Layer) as used in XMPP is broken. In this blog post I&rsquo;ll try to explain why and propose some fixes.
Update (2023-04-21): Since I originally wrote this blog post, I&rsquo;ve had the ability to discuss several of my ideas with Dave (the original author of XEP-0388 dubbed SASL2), MattJ (one of the authors of the prosody xmpp server) and others. Most, if not all, of my issues are now addressed in a bunch of updates to existing XEPs as well as new XEPs:"><meta name=author content="Thilo Molitor"><link crossorigin=anonymous href=/monal-im.org/assets/css/stylesheet.b1ee2dcfd2efef5f2c2a5fa15d30cb52495473ff1c269ca8271b5a37951f90dc.css integrity="sha256-se4tz9Lv718sKl+hXTDLUklUc/8cJpyoJxtaN5UfkNw=" rel="preload stylesheet" as=style fetchpriority=high><script defer crossorigin=anonymous src=/monal-im.org/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=apple-touch-icon sizes=57x57 href=https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_57x0_resize_q50_linear_3.png fetchpriority=medium>
<link rel=apple-touch-icon sizes=60x60 href=https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_60x0_resize_q50_linear_3.png fetchpriority=medium><link rel=apple-touch-icon sizes=72x72 href=https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_72x0_resize_q50_linear_3.png fetchpriority=medium><link rel=apple-touch-icon sizes=76x76 href=https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_76x0_resize_q50_linear_3.png fetchpriority=medium><link rel=apple-touch-icon sizes=114x114 href=https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_114x0_resize_q50_linear_3.png fetchpriority=low><link rel=apple-touch-icon sizes=120x120 href=https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_120x0_resize_q50_linear_3.png fetchpriority=low><link rel=apple-touch-icon sizes=144x144 href=https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_144x0_resize_q50_linear_3.png fetchpriority=low><link rel=apple-touch-icon sizes=152x152 href=https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_152x0_resize_q50_linear_3.png fetchpriority=low><link rel=apple-touch-icon sizes=180x180 href=https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_180x0_resize_q50_linear_3.png fetchpriority=low><link rel=icon type=image/x-icon href=https://monal-im.github.io/monal-im.org/favicons/favicon.ico fetchpriority=medium><link rel=icon type=image/png sizes=16x16 href=https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_16x0_resize_q50_linear_3.png fetchpriority=medium><link rel=icon type=image/png sizes=32x32 href=https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_32x0_resize_q50_linear_3.png fetchpriority=medium><link rel=icon type=image/png sizes=96x96 href=https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_96x0_resize_q50_linear_3.png fetchpriority=low><link rel=icon type=image/png sizes=128x128 href=https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_128x0_resize_q50_linear_3.png fetchpriority=low><link rel=icon type=image/png sizes=196x196 href=https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_196x0_resize_q50_linear_3.png fetchpriority=low><link rel=mask-icon color=red href=favicons/safari-pinned-tab.svg fetchpriority=low><meta name=application-name content="Monal-IM"><meta name=msapplication-TileColor content="#FFFFFF"><meta name=msapplication-square70x70logo content="https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_70x0_resize_q50_linear_3.png" fetchpriority=medium><meta name=msapplication-TileImage content="https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_144x0_resize_q50_linear_3.png" fetchpriority=low><meta name=msapplication-square150x150logo content="https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_150x0_resize_q50_linear_3.png" fetchpriority=low><meta name=msapplication-square310x310logo content="https://monal-im.github.io/monal-im.org/favicons/logo_hu5c261d5fb2d5b79cc5bd3714ad2f2de0_42538_310x0_resize_q50_linear_3.png" fetchpriority=low><meta property="og:title" content="On the state of SASL in XMPP"><meta property="og:description" content="SASL (Simple Authentication and Security Layer) as used in XMPP is broken. In this blog post I&rsquo;ll try to explain why and propose some fixes.
Update (2023-04-21): Since I originally wrote this blog post, I&rsquo;ve had the ability to discuss several of my ideas with Dave (the original author of XEP-0388 dubbed SASL2), MattJ (one of the authors of the prosody xmpp server) and others. Most, if not all, of my issues are now addressed in a bunch of updates to existing XEPs as well as new XEPs:"><meta property="og:type" content="article"><meta property="og:url" content="https://monal-im.github.io/monal-im.org/post/00004-sasl/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-06T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-06T00:00:00+00:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://monal-im.github.io/monal-im.org/post/"},{"@type":"ListItem","position":2,"name":"On the state of SASL in XMPP","item":"https://monal-im.github.io/monal-im.org/post/00004-sasl/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"On the state of SASL in XMPP","name":"On the state of SASL in XMPP","description":"SASL (Simple Authentication and Security Layer) as used in XMPP is broken. In this blog post I\u0026rsquo;ll try to explain why and propose some fixes.\nUpdate (2023-04-21): Since I originally wrote this blog post, I\u0026rsquo;ve had the ability to discuss several of my ideas with Dave (the original author of XEP-0388 dubbed SASL2), MattJ (one of the authors of the prosody xmpp server) and others. Most, if not all, of my issues are now addressed in a bunch of updates to existing XEPs as well as new XEPs:","keywords":[],"articleBody":"SASL (Simple Authentication and Security Layer) as used in XMPP is broken. In this blog post I’ll try to explain why and propose some fixes.\nUpdate (2023-04-21): Since I originally wrote this blog post, I’ve had the ability to discuss several of my ideas with Dave (the original author of XEP-0388 dubbed SASL2), MattJ (one of the authors of the prosody xmpp server) and others. Most, if not all, of my issues are now addressed in a bunch of updates to existing XEPs as well as new XEPs:\nUpdate of XEP-0388 (SASL2): https://xmpp.org/extensions/xep-0388.html New SASL2- and SCRAM-upgrade XEP: https://xmpp.org/extensions/xep-0480.html New XEP for downgrade protection when using SCRAM: https://xmpp.org/extensions/xep-0474.html Already existing XEP that only now gets adopted by server developers: XEP-0440 The rest of this blog post remains as is and can be used for a deeper introduction into the material and as explanation of some of the rationale behind the SASL2 updates and my ProtoXEP.\nA Modern Authentication Protocol In my opinion a modern authentication protocol should have at least the following properties. Of course that can be subject to debate, but I think most of us will agree on the following list.\nallow for protocol agility (e.g. adding new authentication mechanisms, like adding new cipher suites in TLS) prevent downgrade attacks on authentication mechanisms (we don’t want an active attacker to be able to force us to use a weak mechanism) prevent storage of plaintext passwords on the server (that’s obvious: we don’t want a hacker to be able to steal our plaintext passwords once he hacked the database) prevent replay attacks (we don’t want a MITM (man in the middle) be able to steal a (possibly hashed) password and use it to authenticate herself) (possibly) prevent/detect MITM altogether How SASL tries to fulfill these properties First of all: XMPP Core mandates the use of TLS for everything, including authentication. Keep that in mind, when reading the rest of this blog post.\nProperty 1 SASL as defined for XMPP allows the server to present a list of authentication methods. The client then picks the one having the highest perceived strength (see XMPP-Core 6.3.3) among the ones it implements. XEP-0438: Best practices for password hashing and storage lists some common authentication methods and how they should be ordered. Currently, the methods PLAIN (plaintext password), EXTERNAL (using client certificates to authenticate the user) and SCRAM (Salted Challenge Response Authentication Mechanism) are common.\n(I will not talk about SASL EXTERNAL in this blog post, because it does not use passwords and seems to be super uncommon in the XMPP world.)\nThis generally allows adding new mechanisms in the future, protocol agility seems to be fulfilled, right?\nProperty 3 Current mandatory SASL methods include SCRAM-SHA-1 and SCRAM-SHA-1-PLUS (if possible). SCRAM generally allows the server to store a salted hash instead of plaintext passwords.\nEven if the client uses the PLAIN method, the server could store the password as salted hash.\nAnd EXTERNAL usually does not use any form of password.\nSo that’s another property of our list that is fulfilled, right?\nProperty 4 Using SCRAM it is even possible to prevent replay attacks because of the used challenge-response scheme. That’s even possible if no TLS channel is used.\nCool, another property that’s fulfilled by SCRAM as well, right?\nProperty 5 SCRAM is even cooler because it allows for TLS channel-binding.\nThis allows both entities (client and server) taking part in the SCRAM authentication to bind the authentication to the TLS channel using a HMAC (Hash-Based Message Authentication Code) to sign a unique data blob tied to the TLS session in use.\nIf the TLS channel is intercepted by a MITM, the attacker would have to use two separate TLS channels, one to the server and one to the client.\nBinding the authentication to the TLS channel allows the server and client to detect such an attacker and fail the authentication.\nTo indicate, that a server supports channel-binding, it appends the string -PLUS to the advertised SCRAM methods.\nIf the client supports channel-binding, it picks SCRAM-SHA-1-PLUS instead of SCRAM-SHA-1.\nIn case the client supports channel-binding, but only received methods without channel-binding, the client uses the SCRAM method without -PLUS, but also indicates that it would have used the PLUS varriant if offered by the server (SCRAM Channel Binding).\nThis allows for the server to detect downgrade attacks and fail the authentication.\nBecause there are multiple different kinds of channel-binding to TLS possible, the client also specifies which binding it uses during the SCRAM flow (protocol agility).\nChannel binding prevents MITM altogether, right? Another property that’s fulfilled!\nWhat’s broken with SASL in XMPP Cautious readers will have noticed, that I left out property 2 (downgrade attack prevention) in my above explanation. That’s because SASL does not prevent downgrade attacks regarding the method negotiation at all. And that’s one of the main reasons why the whole SASL in XMPP stuff is so horribly broken.\nDowngrade of SASL methods The XMPP Core RFC even mentions downgrade attacks and suggests using TLS to mitigate them. But that’s not enough. If we assume the TLS channel to always be secure and MITM-free, we don’t even need SCRAM but could solely use PLAIN. The TLS channel already ensures no replay attacks can happen and storing the passwords securely using salted hashes on the server is still possible. We don’t need any channel-binding either, because that’s only needed if we assume someone has tampered with the TLS channel in the first place. In this scenario MITM-Prevention (property 5) is simply out of scope for SASL, because we assume TLS to always be MITM-free. That means our properties mentioned above are all fulfilled (property 5 by definition, the other ones by use of TLS) even if we abandon SCRAM and solely use PLAIN.\nIf we, on the other hand, don’t assume to always have a MITM-free TLS channel, then the above listed properties 2, 4 and 5 are all not fulfilled (that means: no downgrade prevention, no replay attack prevention and no MITM detection/prevention). The attacker could simply remove every advertised SASL method except PLAIN and thus get the plaintext password which is replayable and neither the server nor the client will detect this MITM. Supporting SCRAM in clients and servers does not help at all with this, because it simply will not be negotiated.\nWell, okay, but XEP-0438: Best practices for password hashing and storage (and some RFC I don’t remember) says, we should pin the last used SASL mechanism in the client to prevent downgrade attacks in further SASL sessions. That way the client won’t use SASL mechanisms having a perceived lower strength than the pinned one. Using a stronger one is still possible. That’s right, but it makes matters worse in regard to protocol agility while still not preventing the downgrade attack for the first connection of a client to the XMPP server.\nBroken protocol agility Protocol agility means we can specify new authentication methods later on and our client will always use the best one advertised by the server. That’s important because it allows us to gradually upgrade the security strength of our authentication while still maintaining backwards compatibility with older clients, eventually removing an old authentication method once most/all clients use a newer one (like replacing DIGEST-MD5 or CRAM-MD5 with SCRAM-SHA-XXX).\nSCRAM without PLUS variants Because of SCRAM fulfilling property 3 (preventing storage of plaintext passwords on the server), we can not upgrade the stored password hashes in the server’s database to a new SCRAM-based SASL mechanism. The obvious partial solution is to store new user’s passwords using the newer SCRAM algorithm and leave the old user’s passwords like they are. That way at least some of your users get to use the new SCRAM algorithm, slowly phasing out the old one eventually. An example would be a server that previously only supported SCRAM-SHA-1 now advertising support for SCRAM-SHA-256.\nOh, no! That doesn’t work either! The current specification of SASL in XMPP does send the list of supported SASL methods to the client before knowing which username the client wants to authenticate for. That means the server will always advertise SCRAM-SHA-256, even if the hash in the database is still SHA-1. If the client supports SCRAM-SHA-256 as well, it will happily pick that one and the server, only having the SHA-1 hash at hand, won’t be able to authenticate the user. The client on the other hand will have no way to detect why the authentication failed and switch to a percieved lower strength SASL algorithm (and even if that would be possible, it could possibly be used as a downgrade vector if done wrong).\nWell, method pinning to the rescue! We already talked about SASL method pinning. The client obviously knows which SASL method it used the last time it authenticated successfully and can always use just this method, no other, even if it implements some having a higher strength. That extends the pinning described in XEP-0438: Best practices for password hashing and storage to algorithms having a higher strength as well, something that, to my knowledge, isn’t specified anywhere. Additionally, that means we completely loose protocol agility after our first authentication. And newly offering SCRAM-SHA-256 on a server not storing plaintext passwords after it previously only advertised SCRAM-SHA-1 will likely still break authentication for all clients not doing this exact “always use the mechanism used on first auth” pinning.\nThe only way to advertise support for a new SCRAM hash algorithm and make clients use it is to upgrade your complete password database on the server by forcing a password reset upon all of your existing users. This must presumably be done out of band for XMPP. Clients implementing the strict pinning outlined above will have to reset the pinning once a new password gets entered by the user. If they don’t do so, this strict pinning to the old algorithm will still be in place and this client won’t be able to authenticate the user after the password reset.\nAnd I’ve not even started to talk about a user having two clients, one that only supports an old SCRAM algorithm (say SCRAM-SHA-1) and one that supports a new one (say SCRAM-SHA-256). The server obviously must store both hashes in its database to allow logins for both clients.\nSounds all pretty bad, right? How come, that hasn’t been discovered yet? Well, someone already identified these problems back in 2019. See this thread on the standards@xmpp.org mailinglist. But no attempt was made to fix them. Even the new XEP-0388: Extensible SASL Profile still uses the same protocol flow with no fix, albeit allowing for additional handshakes during the authorization phase like pipelining a bind request or resumption via XEP-0198: Stream Management onto the authorization.\nSidenote: One could solve this mess by sacrificing property 3 (not storing plaintext passwords on the server). If the plaintext password is stored on the server, every SCRAM algorithm can be used by the client. But do we really want that? At least that would allow the server to advertise new SCRAM algorithms without having to force a password reset.\nSCRAM with PLUS variants When looking at the channel-binding situation we already saw that the client specifies the type of channel-binding it wants to use. That allows for protocol agility, right?\nNo! The client does not have any way to detect which channel-binding type the server supports (appending -PLUS to the advertised SCRAM algorithm does not in any way specify which channel-binding to use). And if the client uses the wrong channel-binding the server does not support, the server will simply fail the authentication. The client will have no way to detect if the authentication failed because of the wrong channel-binding type used or if the actual password was wrong, like with using the “wrong” SASL algorithm above.\nThis renders the whole channel-binding protocol agility completely useless. And protocol agility is needed even for channel-binding!\nSome Solutions Well, that’s pretty bad news, right? But I don’t want to simply rant and leave the shard for someone else to collect, but propose fixes instead. And to my knowledge some of these problems are really fixable.\nIn this section I want to propose fixes to at least some of these problems. These fixes are open to debate and if we come up with even better solutions during this debate, that’d be great.\nRestoring protocol agility for channel-binding The server must not use -PLUS to indicate SCRAM algorithms with channel-binding, but use the name of the concrete channel-binding type as SCRAM algorithm suffix. That way the client will be able to determine if it supports that type of channel-binding and only select those SCRAM algorithms having a channel-binding it supports. The server is only allowed to advertise channel binding methods supported by the currently used channel (e.g. don’t advertise tls-unique on a TLS 1.3 channel, but only tls-exporter (if implemented)). Clients and servers may choose to still support the -PLUS SCRAM method names in addition to these new ones containing the concrete channel-binding type, but I don’t think that gets us anywhere.\nSome examples: SCRAM-SHA-1_TLS-UNIQUE or SCRAM-SHA-512_TLS-EXPORTER. That, of course, does not help at all, if channel-binding support can be rendered useless by a downgrade attack.\nPreventing downgrade of SASL methods Downgrades can be prevented by only allowing SASL EXTERNAL and SCRAM methods (or something similar to SCRAM that then mutual authenticates the whole protocol flow). The SCRAM client-final message must contain a client proof built using a HMAC not only covering the client-first-message-bare, server-first-message and client-final-message-without-proof, but also the (sorted) SASL method list. That allows the server to verify if the client used the correct list and this could not be manipulated, because it is ultimately signed with the client password, a MITM attacker can not know.\nWe can achieve this by adding an optional SCRAM attribute to client-first-message-bare which will be ignored by non-supporting servers, but secure the handshake against downgrades on supporting servers. This attribute (let’s name it d) will contain a base64-encoded hash of the sorted SASL method list as received by the client (using the same hash method as used in the whole SCRAM stuff). The server then checks if that hash matches the one it calculated itself by hashing the sorted SCRAM method list it advertised and fail the authentication, if these hashes don’t match.\nThe sorting can be done alphabetical in ascending order and the individual SASL methods be separated by \u003c like done in XEP-0115: Entity Capabilities before the whole string is hashed.\nWe now have a working downgrade attack prevention that’s even backwards compatible with existing SCRAM methods and servers not supporting this new SCRAM attribute.\nRestoring protocol agility for SASL methods part #1 First of all, the server will have to store SCRAM hashes (or something similar for non-scram methods) for all methods it does support. If the server operator later decides to not offer a specific SASL method anymore, they can delete the (hash) data stored for that method from their server.\nSecond, the server can only advertise those methods it has hashes for in its database. That means it needs to know the username before advertising which methods it supports. This requires a change in the protocol flow for mechanism negotiation, which is not codified in the SASL RFC and can be changed via XEP. A good candidate would be XEP-0388: Extensible SASL Profile (also dubbed SASL2) which is not yet in Final state and thus can be adjusted to our needs.\nLet’s assume a SASL2 protocol flow by advertising support for this protocol, but not simultaneously advertising which SASL methods the server supports. The client would then first send the desired username it wants to authenticate for, and the server would respond with a list of supported SASL mechanisms for exactly this user. The username is of course not safe from a MITM attacker, but it will be included in the SCRAM authentication flow and the server will fail the authentication if that user differs from the one given earlier.\nAn example protocol flow using a modified SASL2 might look as follows (resembling more or less a normal SCRAM flow):\n","wordCount":"3575","inLanguage":"en","datePublished":"2022-10-06T00:00:00Z","dateModified":"2022-10-06T00:00:00Z","author":{"@type":"Person","name":"Thilo Molitor"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://monal-im.github.io/monal-im.org/post/00004-sasl/"},"publisher":{"@type":"Organization","name":"Monal","logo":{"@type":"ImageObject","url":"https://monal-im.github.io/monal-im.org/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://monal-im.github.io/monal-im.org/ accesskey=h title="Monal (Alt + H)">Monal</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li class=menu-item><a href=/monal-im.org/install/ title=Install><span>Install</span></a></li><li class=menu-item><a href=/monal-im.org/support/ title=Support><span>Support</span></a></li><li class=menu-item><a href=/monal-im.org/post/ title=Blog><span>Blog</span></a></li><li class=menu-item><a href=/monal-im.org/privacy/ title=Privacy><span>Privacy</span></a></li><li class=menu-item><a href=/monal-im.org/about/ title=About><span>About</span></a></li><li class=menu-item><a href=https://github.com/monal-im/Monal/wiki/FAQ---Frequently-Asked-Questions title=FAQ><span>FAQ</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li class=menu-item><a href=/monal-im.org/search/ title="Search 🔍 (Alt + /)" accesskey=/><span>Search 🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>On the state of SASL in XMPP</h1><div class=post-meta><span title='2022-10-06 00:00:00 +0000 UTC'>06.10.2022</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Thilo Molitor<a href=/index.xml rel="noopener noreferrer" target=_blank>&nbsp;RSS</a></div></header><div class=post-content><p>SASL (Simple Authentication and Security Layer) <a href=https://xmpp.org/rfcs/rfc6120.html#sasl>as used in XMPP</a> is broken. In this blog post I&rsquo;ll try to explain why and propose some fixes.</p><p><strong>Update (2023-04-21):</strong> Since I originally wrote this blog post, I&rsquo;ve had the ability to discuss several of my ideas with Dave (the original author of XEP-0388 dubbed SASL2), MattJ (one of the authors of the prosody xmpp server) and others.
Most, if not all, of my issues are now addressed in a bunch of updates to existing XEPs as well as new XEPs:</p><ul><li>Update of XEP-0388 (SASL2): <a href=https://xmpp.org/extensions/xep-0388.html>https://xmpp.org/extensions/xep-0388.html</a></li><li>New SASL2- and SCRAM-upgrade XEP: <a href=https://xmpp.org/extensions/xep-0480.html>https://xmpp.org/extensions/xep-0480.html</a></li><li>New XEP for downgrade protection when using SCRAM: <a href=https://xmpp.org/extensions/xep-0474.html>https://xmpp.org/extensions/xep-0474.html</a></li><li>Already existing XEP that only now gets adopted by server developers: <a href=https://xmpp.org/extensions/xep-0440.html>XEP-0440</a></li></ul><p>The rest of this blog post remains as is and can be used for a deeper introduction into the material and as explanation of some of the rationale behind the SASL2 updates and my ProtoXEP.</p><h1 id=a-modern-authentication-protocol>A Modern Authentication Protocol<a hidden class=anchor aria-hidden=true href=#a-modern-authentication-protocol>#</a></h1><p>In my opinion a modern authentication protocol should have at least the following properties. Of course that can be subject to debate, but I think most of us will agree on the following list.</p><ol><li>allow for protocol agility (e.g. adding new authentication mechanisms, like adding new cipher suites in TLS)</li><li>prevent downgrade attacks on authentication mechanisms (we don&rsquo;t want an active attacker to be able to force us to use a weak mechanism)</li><li>prevent storage of plaintext passwords on the server (that&rsquo;s obvious: we don&rsquo;t want a hacker to be able to steal our plaintext passwords once he hacked the database)</li><li>prevent replay attacks (we don&rsquo;t want a MITM (man in the middle) be able to steal a (possibly hashed) password and use it to authenticate herself)</li><li>(possibly) prevent/detect MITM altogether</li></ol><h2 id=how-sasl-tries-to-fulfill-these-properties>How SASL tries to fulfill these properties<a hidden class=anchor aria-hidden=true href=#how-sasl-tries-to-fulfill-these-properties>#</a></h2><p>First of all: <a href=https://xmpp.org/rfcs/rfc6120.html>XMPP Core</a> mandates the use of TLS for everything, including authentication. Keep that in mind, when reading the rest of this blog post.</p><h3 id=property-1>Property 1<a hidden class=anchor aria-hidden=true href=#property-1>#</a></h3><p>SASL <a href=https://xmpp.org/rfcs/rfc6120.html#sasl>as defined for XMPP</a> allows the server to present a list of authentication methods. The client then picks the one having the highest perceived strength (<a href=https://xmpp.org/rfcs/rfc6120.html#sasl-rules-preferences>see XMPP-Core 6.3.3</a>) among the ones it implements. <a href=https://xmpp.org/extensions/xep-0438.html#required>XEP-0438: Best practices for password hashing and storage</a> lists some common authentication methods and how they should be ordered. Currently, the methods PLAIN (plaintext password), EXTERNAL (using client certificates to authenticate the user) and <a href=https://www.rfc-editor.org/rfc/rfc5802>SCRAM</a> (Salted Challenge Response Authentication Mechanism) are common.</p><blockquote><p>(I will not talk about SASL EXTERNAL in this blog post, because it does not use passwords and seems to be super uncommon in the XMPP world.)</p></blockquote><p>This generally allows adding new mechanisms in the future, protocol agility seems to be fulfilled, right?</p><h3 id=property-3>Property 3<a hidden class=anchor aria-hidden=true href=#property-3>#</a></h3><p>Current <a href=https://xmpp.org/rfcs/rfc6120.html#security-mti>mandatory SASL methods</a> include SCRAM-SHA-1 and SCRAM-SHA-1-PLUS (if possible). <a href=https://www.rfc-editor.org/rfc/rfc5802>SCRAM</a> generally allows the server to store a salted hash instead of plaintext passwords.</p><p>Even if the client uses the PLAIN method, the server could store the password as salted hash.<br>And EXTERNAL usually does not use any form of password.</p><p>So that&rsquo;s another property of our list that is fulfilled, right?</p><h3 id=property-4>Property 4<a hidden class=anchor aria-hidden=true href=#property-4>#</a></h3><p>Using <a href=https://www.rfc-editor.org/rfc/rfc5802>SCRAM</a> it is even possible to prevent replay attacks because of the used challenge-response scheme. That&rsquo;s even possible if no TLS channel is used.</p><p>Cool, another property that&rsquo;s fulfilled by SCRAM as well, right?</p><h3 id=property-5>Property 5<a hidden class=anchor aria-hidden=true href=#property-5>#</a></h3><p><a href=https://www.rfc-editor.org/rfc/rfc5802>SCRAM</a> is even cooler because it allows for <a href=https://www.rfc-editor.org/rfc/rfc5929>TLS channel-binding</a>.<br>This allows both entities (client and server) taking part in the SCRAM authentication to bind the authentication to the TLS channel using a HMAC (Hash-Based Message Authentication Code) to sign a unique data blob tied to the TLS session in use.</p><p>If the TLS channel is intercepted by a MITM, the attacker would have to use two separate TLS channels, one to the server and one to the client.<br>Binding the authentication to the TLS channel allows the server and client to detect such an attacker and fail the authentication.</p><p>To indicate, that a server supports channel-binding, it appends the string <code>-PLUS</code> to the advertised SCRAM methods.<br>If the client supports channel-binding, it picks <code>SCRAM-SHA-1-PLUS</code> instead of <code>SCRAM-SHA-1</code>.<br>In case the client supports channel-binding, but only received methods without channel-binding, the client uses the SCRAM method without -PLUS, but also indicates that it would have used the PLUS varriant if offered by the server (<a href=https://www.rfc-editor.org/rfc/rfc5802#section-6>SCRAM Channel Binding</a>).<br>This allows for the server to detect downgrade attacks and fail the authentication.<br>Because there are multiple different kinds of channel-binding to TLS possible, the client also specifies which binding it uses during the SCRAM flow (protocol agility).</p><p>Channel binding prevents MITM altogether, right? Another property that&rsquo;s fulfilled!</p><h1 id=whats-broken-with-sasl-in-xmpp>What&rsquo;s broken with SASL in XMPP<a hidden class=anchor aria-hidden=true href=#whats-broken-with-sasl-in-xmpp>#</a></h1><p>Cautious readers will have noticed, that I left out property 2 (downgrade attack prevention) in my above explanation. That&rsquo;s because SASL does not prevent downgrade attacks regarding the method negotiation at all. And that&rsquo;s one of the main reasons why the whole SASL in XMPP stuff is so horribly broken.</p><h2 id=downgrade-of-sasl-methods>Downgrade of SASL methods<a hidden class=anchor aria-hidden=true href=#downgrade-of-sasl-methods>#</a></h2><p>The XMPP Core RFC even <a href=https://xmpp.org/rfcs/rfc6120.html#security-reuse-sasl>mentions downgrade attacks and suggests using TLS to mitigate them</a>. But that&rsquo;s not enough. If we assume the TLS channel to always be secure and MITM-free, we don&rsquo;t even need <a href=https://www.rfc-editor.org/rfc/rfc5802>SCRAM</a> but could solely use PLAIN. The TLS channel already ensures no replay attacks can happen and storing the passwords securely using salted hashes on the server is still possible. We don&rsquo;t need any channel-binding either, because that&rsquo;s only needed if we assume someone has tampered with the TLS channel in the first place. In this scenario MITM-Prevention (property 5) is simply out of scope for SASL, because we assume TLS to always be MITM-free. That means our properties mentioned above are all fulfilled (property 5 by definition, the other ones by use of TLS) even if we abandon SCRAM and solely use PLAIN.</p><p>If we, on the other hand, don&rsquo;t assume to always have a MITM-free TLS channel, then the above listed properties 2, 4 and 5 are all not fulfilled (that means: no downgrade prevention, no replay attack prevention and no MITM detection/prevention). The attacker could simply remove every advertised SASL method except PLAIN and thus get the plaintext password which is replayable and neither the server nor the client will detect this MITM. Supporting SCRAM in clients and servers does not help at all with this, because it simply will not be negotiated.</p><p>Well, okay, but <a href=https://xmpp.org/extensions/xep-0438.html#pinning>XEP-0438: Best practices for password hashing and storage</a> (and some RFC I don&rsquo;t remember) says, we should pin the last used SASL mechanism in the client to prevent downgrade attacks in further SASL sessions. That way the client won&rsquo;t use SASL mechanisms having a perceived lower strength than the pinned one. Using a stronger one is still possible. That&rsquo;s right, but it makes matters worse in regard to protocol agility while still not preventing the downgrade attack for the first connection of a client to the XMPP server.</p><h2 id=broken-protocol-agility>Broken protocol agility<a hidden class=anchor aria-hidden=true href=#broken-protocol-agility>#</a></h2><p>Protocol agility means we can specify new authentication methods later on and our client will always use the best one advertised by the server. That&rsquo;s important because it allows us to gradually upgrade the security strength of our authentication while still maintaining backwards compatibility with older clients, eventually removing an old authentication method once most/all clients use a newer one (like replacing DIGEST-MD5 or CRAM-MD5 with SCRAM-SHA-XXX).</p><h3 id=scram-without-plus-variants>SCRAM <em>without</em> PLUS variants<a hidden class=anchor aria-hidden=true href=#scram-without-plus-variants>#</a></h3><p>Because of SCRAM fulfilling property 3 (preventing storage of plaintext passwords on the server), we can not upgrade the stored password hashes in the server&rsquo;s database to a new SCRAM-based SASL mechanism. The obvious partial solution is to store new user&rsquo;s passwords using the newer SCRAM algorithm and leave the old user&rsquo;s passwords like they are. That way at least <em>some</em> of your users get to use the new SCRAM algorithm, slowly phasing out the old one eventually. An example would be a server that previously only supported SCRAM-SHA-1 now advertising support for SCRAM-SHA-256.</p><p>Oh, no! That doesn&rsquo;t work either! The current <a href=https://xmpp.org/rfcs/rfc6120.html#sasl>specification of SASL in XMPP</a> does send the list of supported SASL methods to the client before knowing which username the client wants to authenticate for. That means the server will always advertise SCRAM-SHA-256, even if the hash in the database is still SHA-1. If the client supports SCRAM-SHA-256 as well, it will happily pick that one and the server, only having the SHA-1 hash at hand, won&rsquo;t be able to authenticate the user. The client on the other hand will have no way to detect why the authentication failed and switch to a percieved lower strength SASL algorithm (and even if that would be possible, it could possibly be used as a downgrade vector if done wrong).</p><p>Well, method pinning to the rescue! We already talked about SASL method pinning. The client obviously knows which SASL method it used the last time it authenticated successfully and can always use just this method, no other, even if it implements some having a higher strength. That extends the pinning described in <a href=https://xmpp.org/extensions/xep-0438.html#pinning>XEP-0438: Best practices for password hashing and storage</a> to algorithms having a higher strength as well, something that, to my knowledge, isn&rsquo;t specified anywhere. Additionally, that means we completely loose protocol agility after our first authentication. And newly offering SCRAM-SHA-256 on a server not storing plaintext passwords after it previously only advertised SCRAM-SHA-1 will likely still break authentication for all clients not doing this exact &ldquo;always use the mechanism used on first auth&rdquo; pinning.</p><p>The only way to advertise support for a new SCRAM hash algorithm and make clients use it is to upgrade your complete password database on the server by forcing a password reset upon all of your existing users. This must presumably be done out of band for XMPP. Clients implementing the strict pinning outlined above will have to reset the pinning once a new password gets entered by the user. If they don&rsquo;t do so, this strict pinning to the old algorithm will still be in place and this client won&rsquo;t be able to authenticate the user after the password reset.</p><p>And I&rsquo;ve not even started to talk about a user having two clients, one that only supports an old SCRAM algorithm (say SCRAM-SHA-1) and one that supports a new one (say SCRAM-SHA-256). The server obviously must store both hashes in its database to allow logins for both clients.</p><p>Sounds all pretty bad, right? How come, that hasn&rsquo;t been discovered yet? Well, someone already identified these problems back in 2019. See <a href=https://mail.jabber.org/pipermail/standards/2019-January/035720.html>this thread</a> on the <a href=mailto:standards@xmpp.org>standards@xmpp.org</a> mailinglist. But no attempt was made to fix them. Even the new <a href=https://xmpp.org/extensions/xep-0388.html>XEP-0388: Extensible SASL Profile</a> still uses the same protocol flow with no fix, albeit allowing for additional handshakes during the authorization phase like pipelining a bind request or <a href=https://xmpp.org/extensions/xep-0198.html>resumption via XEP-0198: Stream Management</a> onto the authorization.</p><p>Sidenote: One could solve this mess by sacrificing property 3 (not storing plaintext passwords on the server). If the plaintext password is stored on the server, every SCRAM algorithm can be used by the client. But do we really want that? At least that would allow the server to advertise new SCRAM algorithms without having to force a password reset.</p><h3 id=scram-with-plus-variants>SCRAM <em>with</em> PLUS variants<a hidden class=anchor aria-hidden=true href=#scram-with-plus-variants>#</a></h3><p>When looking at the channel-binding situation we already saw that the client specifies the type of channel-binding it wants to use. That allows for protocol agility, right?</p><p>No! The client does not have any way to detect which channel-binding type the server supports (appending <code>-PLUS</code> to the advertised SCRAM algorithm does not in any way specify which channel-binding to use). And if the client uses the wrong channel-binding the server does not support, the server will simply fail the authentication. The client will have no way to detect if the authentication failed because of the wrong channel-binding type used or if the actual password was wrong, like with using the &ldquo;wrong&rdquo; SASL algorithm above.</p><p>This renders the whole channel-binding protocol agility completely useless. <a href=https://www.rfc-editor.org/rfc/rfc9266#section-1>And protocol agility is needed even for channel-binding!</a></p><h1 id=some-solutions>Some Solutions<a hidden class=anchor aria-hidden=true href=#some-solutions>#</a></h1><p>Well, that&rsquo;s pretty bad news, right? But I don&rsquo;t want to simply rant and leave the shard for someone else to collect, but propose fixes instead. And to my knowledge some of these problems are really fixable.</p><p>In this section I want to propose fixes to at least some of these problems. These fixes are open to debate and if we come up with even better solutions during this debate, that&rsquo;d be great.</p><h2 id=restoring-protocol-agility-for-channel-binding>Restoring protocol agility for channel-binding<a hidden class=anchor aria-hidden=true href=#restoring-protocol-agility-for-channel-binding>#</a></h2><p>The server must not use <code>-PLUS</code> to indicate SCRAM algorithms with channel-binding, but use the name of the concrete channel-binding type as SCRAM algorithm suffix. That way the client will be able to determine if it supports that type of channel-binding and only select those SCRAM algorithms having a channel-binding it supports. The server is only allowed to advertise channel binding methods supported by the currently used channel (e.g. don&rsquo;t advertise <code>tls-unique</code> on a TLS 1.3 channel, but only <code>tls-exporter</code> (if implemented)). Clients and servers may choose to still support the <code>-PLUS</code> SCRAM method names in addition to these new ones containing the concrete channel-binding type, but I don&rsquo;t think that gets us anywhere.</p><p>Some examples: <code>SCRAM-SHA-1_TLS-UNIQUE</code> or <code>SCRAM-SHA-512_TLS-EXPORTER</code>. That, of course, does not help at all, if channel-binding support can be rendered useless by a downgrade attack.</p><h2 id=preventing-downgrade-of-sasl-methods>Preventing downgrade of SASL methods<a hidden class=anchor aria-hidden=true href=#preventing-downgrade-of-sasl-methods>#</a></h2><p>Downgrades can be prevented by only allowing SASL EXTERNAL and SCRAM methods (or something similar to SCRAM that then mutual authenticates the whole protocol flow). The <a href=https://www.rfc-editor.org/rfc/rfc5802>SCRAM</a> client-final message must contain a client proof built using a HMAC not only covering the <code>client-first-message-bare</code>, <code>server-first-message</code> and <code>client-final-message-without-proof</code>, but also the (sorted) SASL method list. That allows the server to verify if the client used the correct list and this could not be manipulated, because it is ultimately signed with the client password, a MITM attacker can not know.</p><p>We can achieve this by adding an optional SCRAM attribute to <code>client-first-message-bare</code> which will be ignored by non-supporting servers, but secure the handshake against downgrades on supporting servers. This attribute (let&rsquo;s name it <code>d</code>) will contain a base64-encoded hash of the sorted SASL method list as received by the client (using the same hash method as used in the whole SCRAM stuff). The server then checks if that hash matches the one it calculated itself by hashing the sorted SCRAM method list it advertised and fail the authentication, if these hashes don&rsquo;t match.</p><p>The sorting can be done alphabetical in ascending order and the individual SASL methods be separated by <code>&lt;</code> like done in <a href=https://xmpp.org/extensions/xep-0115.html>XEP-0115: Entity Capabilities</a> before the whole string is hashed.</p><p>We now have a working downgrade attack prevention that&rsquo;s even backwards compatible with existing SCRAM methods and servers not supporting this new SCRAM attribute.</p><h2 id=restoring-protocol-agility-for-sasl-methods-part-1>Restoring protocol agility for SASL methods part #1<a hidden class=anchor aria-hidden=true href=#restoring-protocol-agility-for-sasl-methods-part-1>#</a></h2><p>First of all, the server will have to store SCRAM hashes (or something similar for non-scram methods) for all methods it does support. If the server operator later decides to not offer a specific SASL method anymore, they can delete the (hash) data stored for that method from their server.</p><p>Second, the server can only advertise those methods it has hashes for in its database. That means it needs to know the username before advertising which methods it supports. This requires a change in the protocol flow for mechanism negotiation, which is not codified in the SASL RFC and can be changed via XEP. A good candidate would be <a href=https://xmpp.org/extensions/xep-0388.html>XEP-0388: Extensible SASL Profile</a> (also dubbed SASL2) which is not yet in <code>Final</code> state and thus can be adjusted to our needs.</p><p>Let&rsquo;s assume a SASL2 protocol flow by advertising support for this protocol, but not simultaneously advertising which SASL methods the server supports. The client would then first send the desired username it wants to authenticate for, and the server would respond with a list of supported SASL mechanisms for exactly this user. The username is of course not safe from a MITM attacker, but it will be included in the SCRAM authentication flow and the server will fail the authentication if that user differs from the one given earlier.</p><p>An example protocol flow using a modified SASL2 might look as follows (resembling more or less a normal SCRAM flow):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  Server sends stream features indicating support for SASL2.
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;stream:features&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;authentication</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/stream:features&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  Client intiates authentication by sending the base64 encoded username it wishes to authenticate for.
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;request</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;user&gt;</span>dXNlcg==<span style=color:#f92672>&lt;/user&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/request&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  Server sends the list of supported mechanisms for this user.
</span></span></span><span style=display:flex><span><span style=color:#75715e>  The sorted list will be &#39;SCRAM-SHA-1&lt;SCRAM-SHA-1_TLS-EXPORTER&lt;SCRAM-SHA-256&lt;SCRAM-SHA-256_TLS-EXPORTER&#39;,
</span></span></span><span style=display:flex><span><span style=color:#75715e>  the corresponding base64 encoded SHA-1 hash (SHA-1 will be used because negotiated below) is: &#39;U3vZANxXbl1pMOMBAFPnTb5YXWk=&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;mechanisms</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;mechanism&gt;</span>SCRAM-SHA-1<span style=color:#f92672>&lt;/mechanism&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;mechanism&gt;</span>SCRAM-SHA-1_TLS-EXPORTER<span style=color:#f92672>&lt;/mechanism&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;mechanism&gt;</span>SCRAM-SHA-256<span style=color:#f92672>&lt;/mechanism&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;mechanism&gt;</span>SCRAM-SHA-256_TLS-EXPORTER<span style=color:#f92672>&lt;/mechanism&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/mechanisms&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  Client sends the selected mechanism alogside the initial-response data.
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;authenticate</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span> <span style=color:#a6e22e>mechanism=</span><span style=color:#e6db74>&#39;SCRAM-SHA-1_TLS-EXPORTER&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>&lt;!-- Base64 of: &#39;p=tls-exporter,,n=user,r=12C4CD5C-E38E-4A98-8F6D-15C38F51CCC6,d=U3vZANxXbl1pMOMBAFPnTb5YXWk=&#39; --&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;initial-response&gt;</span>cD10bHMtZXhwb3J0ZXIsLG49dXNlcixyPTEyQzRDRDVDLUUzOEUtNEE5OC04RjZELTE1QzM4RjUxQ0NDNixkPVUzdlpBTnhYYmwxcE1PTUJBRlBuVGI1WVhXaz0=<span style=color:#f92672>&lt;/initial-response&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/authenticate&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  SCRAM-SHA-1 challenge issued by the server.
</span></span></span><span style=display:flex><span><span style=color:#75715e>  Base64 of: &#39;r=12C4CD5C-E38E-4A98-8F6D-15C38F51CCC6a09117a6-ac50-4f2f-93f1-93799c2bddf6,s=QSXCR+Q6sek8bf92,i=4096&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;challenge</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  cj0xMkM0Q0Q1Qy1FMzhFLTRBOTgtOEY2RC0xNUMzOEY1MUNDQzZhMDkxMTdhNi1hYzUwLTRmMmYtOTNmMS05Mzc5OWMyYmRkZjYscz1RU1hDUitRNnNlazhiZjkyLGk9NDA5Ng==
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/challenge&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  The client responds with the base64 encoded client-final-message (password: &#39;pencil&#39;).
</span></span></span><span style=display:flex><span><span style=color:#75715e>  Base64 of: &#39;c=cD10bHMtZXhwb3J0ZXIsLMcoQvOdBDePd4OswlmAWV3dg1a1Wh1tYPTBwVid10VU,r=12C4CD5C-E38E-4A98-8F6D-15C38F51CCC6a09117a6-ac50-4f2f-93f1-93799c2bddf6,p=icrRuoQBB0htw5+K/6RNEDJ0Q4Y=&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e>  The c-attribute contains the GS2-header and channel-binding data blob (32 bytes).
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;response</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  Yz1jRDEwYkhNdFpYaHdiM0owWlhJc0xNY29Rdk9kQkRlUGQ0T3N3bG1BV1YzZGcxYTFXaDF0WVBUQndWaWQxMFZVLHI9MTJDNENENUMtRTM4RS00QTk4LThGNkQtMTVDMzhGNTFDQ0M2YTA5MTE3YTYtYWM1MC00ZjJmLTkzZjEtOTM3OTljMmJkZGY2LHA9aWNyUnVvUUJCMGh0dzUrSy82Uk5FREowUTRZPQ==
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/response&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  This completes, so the Server sends a success containing the base64 encoded server signature.
</span></span></span><span style=display:flex><span><span style=color:#75715e>  A SASL2 success always includes the authorization identifier.
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;success</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;authorization-identifier&gt;</span>user@example.org<span style=color:#f92672>&lt;/authorization-identifier&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>&lt;!-- Base64 of: &#39;v=Ax+ZEP5hf90z8+KnakwspK9mEhk=&#39; --&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;additional-data&gt;</span>
</span></span><span style=display:flex><span>    dj1BeCtaRVA1aGY5MHo4K0tuYWt3c3BLOW1FaGs9
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/additional-data&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/success&gt;</span>
</span></span></code></pre></div><h2 id=restoring-protocol-agility-for-sasl-methods-part-2>Restoring protocol agility for SASL methods part #2<a hidden class=anchor aria-hidden=true href=#restoring-protocol-agility-for-sasl-methods-part-2>#</a></h2><p>Activating a new SASL (SCRAM) method and saving new hashes for these methods for already known users on the server is a bit trickier. To solve this, the server offers new SASL mechanisms indicating that he allows for hash upgrades, if he doesn&rsquo;t have all required hashes in its database yet. The ordering of these new upgrade mechanisms should use a stable sorting algorithm. First sorting by perceived strength of the algorithm updated to, then by the percieved strength of the algorithm used for authentication (e.g. use the highest strength for authentication and upgrade to the highest strength possible with this authentication).</p><p>For reference, the SCRAM flow as stated in <a href=https://www.rfc-editor.org/rfc/rfc5802#section-3>RFC 5802 section 3</a> is as follows, with HMAC() and HASH() corresponding to the hash method used to authenticate (e.g. SHA-256 for SCRAM-SHA-256):</p><pre tabindex=0><code>SaltedPassword  := Hi(Normalize(password), salt, i)
ClientKey       := HMAC(SaltedPassword, &#34;Client Key&#34;)
StoredKey       := H(ClientKey)
AuthMessage     := client-first-message-bare + &#34;,&#34; +
                   server-first-message + &#34;,&#34; +
                   client-final-message-without-proof
ClientSignature := HMAC(StoredKey, AuthMessage)
ClientProof     := ClientKey XOR ClientSignature
ServerKey       := HMAC(SaltedPassword, &#34;Server Key&#34;)
ServerSignature := HMAC(ServerKey, AuthMessage)
</code></pre><p>The <code>SaltedPassword</code> is the hash saved in the database on the server alongside the <code>salt</code>. Using additional SASL2 tasks we can now require the client to perform an additional task which consists of sending the <code>SaltedPassword</code> for the hash algorithm to upgrade to. The server just provides the required salt (that must be a new random value not equal to the one used for the old hash) and iteration count. By providing the salted hash <em>after</em> the successful completion of our SCRAM authentication, server and client can be sure to talk to the right one and when channel-binding is used, both can be sure no MITM is involved that could intercept the new <code>SaltedPassword</code>. I strongly suggest to only support password upgrades if channel-binding is used.</p><p>An example protocol flow using a modified SASL2 might look as follows (resembling more or less the SCRAM flow used in part #1 above and adding a second task for the desired hash upgrade):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  Server sends stream features indicating support for SASL2.
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;stream:features&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;authentication</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/stream:features&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  Client intiates authentication by sending the base64 encoded username it wishes to authenticate for.
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;request</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;user&gt;</span>dXNlcg==<span style=color:#f92672>&lt;/user&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/request&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  Server sends the list of supported mechanisms for this user.
</span></span></span><span style=display:flex><span><span style=color:#75715e>  The sorted list will be &#39;SCRAM-SHA-1_TLS-EXPORTER&lt;SCRAM-SHA-256_TLS-EXPORTER&lt;UPGRADE-SCRAM-SHA-256_SCRAM-SHA-1&lt;UPGRADE-SCRAM-SHA-256_SCRAM-SHA-1_TLS-EXPORTER&#39;,
</span></span></span><span style=display:flex><span><span style=color:#75715e>  the corresponding base64 encoded SHA-1 hash (SHA-1 will be used because negotiated below) is: &#39;nKFUXQ7h9IL3eo17pKygmacnEsk=&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;mechanisms</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;mechanism&gt;</span>SCRAM-SHA-1<span style=color:#f92672>&lt;/mechanism&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;mechanism&gt;</span>SCRAM-SHA-1_TLS-EXPORTER<span style=color:#f92672>&lt;/mechanism&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;mechanism&gt;</span>UPGRADE-SCRAM-SHA-256_SCRAM-SHA-1<span style=color:#f92672>&lt;/mechanism&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;mechanism&gt;</span>UPGRADE-SCRAM-SHA-256_SCRAM-SHA-1_TLS-EXPORTER<span style=color:#f92672>&lt;/mechanism&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/mechanisms&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  Client sends the selected mechanism alogside the initial-response data.
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;authenticate</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span> <span style=color:#a6e22e>mechanism=</span><span style=color:#e6db74>&#39;SCRAM-SHA-1_TLS-EXPORTER&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>&lt;!-- Base64 of: &#39;p=tls-exporter,,n=user,r=12C4CD5C-E38E-4A98-8F6D-15C38F51CCC6,d=nKFUXQ7h9IL3eo17pKygmacnEsk=&#39; --&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;initial-response&gt;</span>cD10bHMtZXhwb3J0ZXIsLG49dXNlcixyPTEyQzRDRDVDLUUzOEUtNEE5OC04RjZELTE1QzM4RjUxQ0NDNixkPVUzdlpBTnhYYmwxcE1PTUJBRlBuVGI1WVhXaz0=<span style=color:#f92672>&lt;/initial-response&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/authenticate&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  SCRAM-SHA-1 challenge issued by the server.
</span></span></span><span style=display:flex><span><span style=color:#75715e>  Base64 of: &#39;r=12C4CD5C-E38E-4A98-8F6D-15C38F51CCC6a09117a6-ac50-4f2f-93f1-93799c2bddf6,s=QSXCR+Q6sek8bf92,i=4096&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;challenge</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  cj0xMkM0Q0Q1Qy1FMzhFLTRBOTgtOEY2RC0xNUMzOEY1MUNDQzZhMDkxMTdhNi1hYzUwLTRmMmYtOTNmMS05Mzc5OWMyYmRkZjYscz1RU1hDUitRNnNlazhiZjkyLGk9NDA5Ng==
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/challenge&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  The client responds with the base64 encoded client-final-message (password: &#39;pencil&#39;).
</span></span></span><span style=display:flex><span><span style=color:#75715e>  Base64 of: &#39;c=cD10bHMtZXhwb3J0ZXIsLMcoQvOdBDePd4OswlmAWV3dg1a1Wh1tYPTBwVid10VU,r=12C4CD5C-E38E-4A98-8F6D-15C38F51CCC6a09117a6-ac50-4f2f-93f1-93799c2bddf6,p=UApo7xo6Pa9J+Vaejfz/dG7BomU=&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e>  The c-attribute contains the GS2-header and channel-binding data blob (32 bytes).
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;response</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  Yz1jRDEwYkhNdFpYaHdiM0owWlhJc0xNY29Rdk9kQkRlUGQ0T3N3bG1BV1YzZGcxYTFXaDF0WVBUQndWaWQxMFZVLHI9MTJDNENENUMtRTM4RS00QTk4LThGNkQtMTVDMzhGNTFDQ0M2YTA5MTE3YTYtYWM1MC00ZjJmLTkzZjEtOTM3OTljMmJkZGY2LHA9VUFwbzd4bzZQYTlKK1ZhZWpmei9kRzdCb21VPQ==
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/response&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  This completes, so the Server sends a continue containing the base64 encoded server signature and the upgrade task to perform.
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;continue</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;authorization-identifier&gt;</span>user@example.org<span style=color:#f92672>&lt;/authorization-identifier&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>&lt;!-- Base64 of: &#39;msVHs/BzIOHDqXeVH7EmmDu9id8=&#39; --&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;additional-data&gt;</span>
</span></span><span style=display:flex><span>    dj1tc1ZIcy9CeklPSERxWGVWSDdFbW1EdTlpZDg9
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/additional-data&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;tasks&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;task&gt;</span>UPGRADE-SCRAM-SHA-256<span style=color:#f92672>&lt;/task&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/tasks&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/continue&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  The client provides the SaltedPassword hash for SCRAM-SHA-256
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;next</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span> <span style=color:#a6e22e>task=</span><span style=color:#e6db74>&#39;UPGRADE-SCRAM-SHA-256&#39;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  The server sends the required salt and iteration count encoded as base64 encoded SASL attributes.
</span></span></span><span style=display:flex><span><span style=color:#75715e>  Base64 of: &#39;s=A_SXCRXQ6sek8bf_Z,i=4096&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;challenge</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  cz1BX1NYQ1JYUTZzZWs4YmZfWixpPTQwOTY=
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/challenge&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  The client responds with the base64 encoded SaltedPassword.
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;response</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  BzOnw3Pc5H4bOLlPZ/8JAy6wnTpH05aH21KW2+Xfpaw=
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/response&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!--
</span></span></span><span style=display:flex><span><span style=color:#75715e>  Finally, the server sends a success after adding the salted SHA-256 hash to it&#39;s database.
</span></span></span><span style=display:flex><span><span style=color:#75715e>  A SASL2 success always includes the authorization identifier.
</span></span></span><span style=display:flex><span><span style=color:#75715e>--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;success</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#39;urn:xmpp:sasl:1&#39;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;authorization-identifier&gt;</span>user@example.org<span style=color:#f92672>&lt;/authorization-identifier&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/success&gt;</span>
</span></span></code></pre></div><p>If the server needs to upgrade to multiple new SCRAM algorithms, he can do so one at a time on every new authentication. This is no &ldquo;do everything once&rdquo; anyways, because not every client might support every upgrade possible.</p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>To conclude this, we now identified several improvements to regain the properties listed in the beginning. These improvements can mainly be achieved by updating the SASL2 XEP (<a href=https://xmpp.org/extensions/xep-0388.html>XEP-0388: Extensible SASL Profile</a>). The downgrade prevention (the additional SCRAM attribute <code>d</code>) should possibly be published as RFC, but a XEP could suffice, too.</p><p>Feel free to comment on anything in here. I&rsquo;m always open to feedback and improvements. Just contact me at <a href=mailto:thilo@monal-im.org>thilo@monal-im.org</a>.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://monal-im.github.io/monal-im.org/>Monal</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script type=text/javascript src=https://monal-im.github.io/monal-im.org/js/main.min.416309f1329adbd311186e61f8f1d0b56d9c308752b71dd96914593d05ef8166.js integrity="sha256-QWMJ8TKa29MRGG5h+PHQtW2cMIdStx3ZaRRZPQXvgWY="></script></body></html>